[
  {
    "menu": "Getting Started",
    "chapters": [
      {
        "title": "Basic Syntax",
        "url": "https://kotlinlang.org/docs/reference/basic-syntax.html",
        "doms": [
          { "tag": "h1", "content": "Basic Syntax", "anchor": "#basic-syntax" },
          {
            "tag": "h2",
            "content": "Package definition and imports",
            "anchor": "#defining-packages"
          },
          {
            "tag": "pre",
            "content": "import Fondation\n​\n// ..."
          },
          {
            "tag": "h2",
            "content": "Program entry point",
            "anchor": "#program-entry-point"
          },
          {
            "tag": "pre",
            "notSupport": true,
            "content": "❌ Code written at global scope is used as the entry point for the program, so you don’t need a main() function. "
          },
          {
            "tag": "h2",
            "content": "Functions",
            "anchor": "#defining-functions"
          },
          {
            "tag": "pre",
            "content": "func sum(a: Int, b: Int) -> Int {\n    return a + b\n}"
          },
          { "tag": "pre", "notSupport": true, "content": "❌" },
          {
            "tag": "pre",
            "content": "func printSum(a: Int, b: Int) {\n    print(\"sum of \\(a) and \\(b) is \\(a + b)\")\n}"
          },
          {
            "tag": "pre",
            "content": "func printSum(a: Int, b: Int) {\n    print(\"sum of \\(a) and \\(b) is \\(a + b)\")\n}"
          },
          {
            "tag": "h2",
            "content": "Variables",
            "anchor": "#defining-variables"
          },
          {
            "tag": "pre",
            "content": "let a: Int = 1\nlet b = 2\nlet c: Int\nc = 3"
          },
          {
            "tag": "pre",
            "content": "var x = 5\nx += 1"
          },
          {
            "tag": "pre",
            "content": "let PI = 3.14\nvar x = 0\n​\nfunc incrementX() { \n    x += 1 \n}"
          },
          { "tag": "h2", "content": "Comments", "anchor": "#comments" },
          {
            "tag": "pre",
            "content": "// This is an end-of-line comment\n​\n/* This is a block comment\n   on multiple lines. */"
          },
          {
            "tag": "pre",
            "content": "/* The comment starts here\n/* contains a nested comment */     \nand ends here. */"
          },
          {
            "tag": "h2",
            "content": "String templates",
            "anchor": "#using-string-templates"
          },
          {
            "tag": "pre",
            "content": "var a = 1\n\nlet s1 = \"a is \\(a)\" \n​\na = 2\n\nlet s2 = \"\\(s1.replacingOccurrences(of:\"is\", with:\"was\")), but now is \\(a)\""
          },
          {
            "tag": "h2",
            "content": "Conditional expressions",
            "anchor": "#using-conditional-expressions"
          },
          {
            "tag": "pre",
            "content": "func maxOf(a: Int, b: Int) -> Int {\n    if (a > b) {\n        return a\n    } else {\n        return b\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "func maxOf(a: Int, b: Int) -> Int {\n    a > b ? a : b\n}"
          },
          {
            "tag": "h2",
            "content": "Nullable values and null checks",
            "anchor": "#using-nullable-values-and-checking-for-null"
          },
          {
            "tag": "pre",
            "content": "func parseInt(str: String) -> Int? {\n    // ...\n}"
          },
          {
            "tag": "pre",
            "content": "func printProduct(arg1: String, arg2: String) {\n    let x = parseInt(arg1)\n    val y = parseInt(arg2)\n​\n    // Using `x * y` yields error because they may hold nulls.\n    if x != nil && y != nil {\n        // x and y are automatically cast to non-nullable after null check\n        print(x * y)\n    }\n    else {\n        print(\"'\\(arg1)' or '\\(arg2)' is not a number\")\n    }    \n}"
          },
          {
            "tag": "pre",
            "content": "// ...\nguard let x = x else {\n    print(\"Wrong number format in arg1: '\\(arg1)'\")\n    return\n}\nguard let y = y else {\n    print(\"Wrong number format in arg2: '\\(arg2)'\")\n    return\n}\n​\n// x and y are automatically cast to non-nullable after null check\nprint(x * y)"
          },
          {
            "tag": "h2",
            "content": "Type checks and automatic casts",
            "anchor": "#using-type-checks-and-automatic-casts"
          },
          {
            "tag": "pre",
            "content": "func getStringLength(obj: Any) -> Int? {\n    if let string = obj as? String {\n        \n        return string.count\n    }\n​\n    \n    return nil\n}"
          },
          {
            "tag": "pre",
            "content": "func getStringLength(obj: Any) -> Int? {\n    guard let string = obj as? String else { return nil }\n​\n    \n    return string.count\n}"
          },
          {
            "tag": "pre",
            "notSupport": true,
            "content": "❌"
          },
          { "tag": "h2", "content": "for loop", "anchor": "#using-a-for-loop" },
          {
            "tag": "pre",
            "content": "let items = [\"apple\", \"banana\", \"kiwifruit\"]\nfor item in items {\n    print(item)\n}"
          },
          {
            "tag": "pre",
            "content": "let items = [\"apple\", \"banana\", \"kiwifruit\"]\nfor (index, item) in items.enumerated() { {\n    print(\"item at \\(index) is \\(item)\")\n}"
          },
          {
            "tag": "h2",
            "content": "while loop",
            "anchor": "#using-a-while-loop"
          },
          {
            "tag": "pre",
            "content": "let items = [\"apple\", \"banana\", \"kiwifruit\"]\nvar index = 0\nwhile index < items.count {\n    print(\"item at \\(index) is \\(items[index])\")\n    index += 1\n}"
          },
          {
            "tag": "h2",
            "content": "when expression",
            "anchor": "#using-when-expression"
          },
          {
            "tag": "pre",
            "content": "func describe(obj: Any): String =\n    when (obj) {\n        1          -> \"One\"\n        \"Hello\"    -> \"Greeting\"\n        is Long    -> \"Long\"\n        !is String -> \"Not a string\"\n        else       -> \"Unknown\"\n    }"
          },
          { "tag": "h2", "content": "Ranges", "anchor": "#using-ranges" },
          {
            "tag": "pre",
            "content": "let x = 10\nlet y = 9\nif (x in 1..y+1) {\n    print(\"fits in range\")\n}"
          },
          {
            "tag": "pre",
            "content": "let list = [\"a\", \"b\", \"c\")\n​\nif (-1 !in 0..list.lastIndex) {\n    print(\"-1 is out of range\")\n}\nif (list.size !in list.indices) {\n    print(\"list size is out of valid list indices range, too\")\n}"
          },
          { "tag": "pre", "content": "for (x in 1..5) {\n    print(x)\n}" },
          {
            "tag": "pre",
            "content": "for (x in 1..10 step 2) {\n    print(x)\n}\nprint()\nfor (x in 9 downTo 0 step 3) {\n    print(x)\n}"
          },
          {
            "tag": "h2",
            "content": "Collections",
            "anchor": "#using-collections"
          },
          {
            "tag": "pre",
            "content": "for (item in items) {\n    print(item)\n}"
          },
          {
            "tag": "pre",
            "content": "when {\n    \"orange\" in items -> print(\"juicy\")\n    \"apple\" in items -> print(\"apple is fine too\")\n}"
          },
          {
            "tag": "pre",
            "content": "let fruits = [\"banana\", \"avocado\", \"apple\", \"kiwifruit\")\nfruits\n  .filter { it.startsWith(\"a\") }\n  .sortedBy { it }\n  .map { it.toUpperCase() }\n  .forEach { print(it) }"
          },
          {
            "tag": "h2",
            "content": "Creating basic classes and their instances",
            "anchor": "#creating-basic-classes-and-their-instances"
          },
          {
            "tag": "pre",
            "content": "let rectangle = Rectangle(5.0, 2.0)\nlet triangle = Triangle(3.0, 4.0, 5.0)"
          }
        ]
      },
      {
        "title": "Idioms",
        "url": "https://kotlinlang.org/docs/reference/idioms.html",
        "doms": []
      },
      {
        "title": "Coding Conventions",
        "url": "https://kotlinlang.org/docs/reference/coding-conventions.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Coding Conventions",
            "anchor": "#coding-conventions"
          },
          { "tag": "h2", "content": "Naming rules", "anchor": "#naming-rules" },
          {
            "tag": "pre",
            "content": "open class DeclarationProcessor { /*...*/ }\n​\nobject EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ }"
          },
          {
            "tag": "h3",
            "content": "Function names",
            "anchor": "#function-names"
          },
          {
            "tag": "pre",
            "content": "func processDeclarations() { /*...*/ }\nvar declarationCount = 1"
          },
          {
            "tag": "pre",
            "content": "interface Foo { /*...*/ }\n​\nclass FooImpl : Foo { /*...*/ }\n​\nfunc Foo(): Foo { return FooImpl() }"
          },
          { "tag": "h4", "content": "Names for test methods" },
          {
            "tag": "pre",
            "content": "class MyTestCase {\n     @Test fun `ensure everything works`() { /*...*/ }\n     \n     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }\n}"
          },
          {
            "tag": "h3",
            "content": "Property names",
            "anchor": "#property-names"
          },
          {
            "tag": "pre",
            "content": "const val MAX_COUNT = 8\nlet USER_NAME_FIELD = \"UserName\""
          },
          {
            "tag": "pre",
            "content": "let mutableCollection: MutableSet<String> = HashSet()"
          },
          {
            "tag": "pre",
            "content": "let PersonComparator: Comparator<Person> = /*...*/"
          },
          { "tag": "h4", "content": "Names for backing properties" },
          {
            "tag": "pre",
            "content": "class C {\n    private val _elementList = mutableListOf<Element>()\n​\n    val elementList: List<Element>\n         get() = _elementList\n}"
          },
          { "tag": "h2", "content": "Formatting", "anchor": "#formatting" },
          {
            "tag": "pre",
            "content": "if elements != nil {\n    for (element in elements) {\n        // ...\n    }\n}"
          },
          {
            "tag": "h3",
            "content": "Horizontal whitespace",
            "anchor": "#horizontal-whitespace"
          },
          {
            "tag": "pre",
            "content": "class A(let x: Int)\n​\nfunc foo(x: Int) { ... }\n​\nfunc bar() {\n    foo(1)\n}"
          },
          { "tag": "h3", "content": "Colon", "anchor": "#colon" },
          {
            "tag": "pre",
            "content": "abstract class Foo<out T : Any> : IFoo {\n    abstract fun foo(a: Int): T\n}\n​\nclass FooImpl : Foo() {\n    constructor(x: String) : this(x) { /*...*/ }\n    \n    let x = object : IFoo { /*...*/ } \n}"
          },
          {
            "tag": "h3",
            "content": "Class header formatting",
            "anchor": "#class-header-formatting"
          },
          { "tag": "pre", "content": "class Person(id: Int, name: String)" },
          {
            "tag": "pre",
            "content": "class Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name) { /*...*/ }"
          },
          {
            "tag": "pre",
            "content": "class Person(\n    id: Int,\n    name: String,\n    surname: String\n) : Human(id, name),\n    KotlinMaker { /*...*/ }"
          },
          {
            "tag": "pre",
            "content": "class MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne {\n​\n    fun foo() { /*...*/ }\n}"
          },
          {
            "tag": "pre",
            "content": "class MyFavouriteVeryLongClassHolder :\n    MyLongHolder<MyFavouriteVeryLongClass>(),\n    SomeOtherInterface,\n    AndAnotherOne \n{\n    fun foo() { /*...*/ }\n}"
          },
          { "tag": "h3", "content": "Modifiers", "anchor": "#modifiers" },
          {
            "tag": "pre",
            "content": "public / protected / private / internal\nexpect / actual\nfinal / open / abstract / sealed / const\nexternal\noverride\nlateinit\ntailrec\nvararg\nsuspend\ninner\nenum / annotation / fun // as a modifier in `fun interface`\ncompanion\ninline\ninfix\noperator\ndata"
          },
          { "tag": "pre", "content": "@Named(\"Foo\")\nprivate val foo: Foo" },
          {
            "tag": "h3",
            "content": "Annotation formatting",
            "anchor": "#annotation-formatting"
          },
          {
            "tag": "pre",
            "content": "@Target(AnnotationTarget.PROPERTY)\nannotation class JsonExclude"
          },
          { "tag": "pre", "content": "@JsonExclude @JvmField\nvar x: String" },
          { "tag": "pre", "content": "@Test fun foo() { /*...*/ }" },
          {
            "tag": "h3",
            "content": "File annotations",
            "anchor": "#file-annotations"
          },
          {
            "tag": "pre",
            "content": "/** License, copyright and whatever */\n@file:JvmName(\"FooBar\")\n​\npackage foo.bar"
          },
          {
            "tag": "h3",
            "content": "Function formatting",
            "anchor": "#function-formatting"
          },
          {
            "tag": "pre",
            "content": "func longMethodName(\n    argument: ArgumentType = defaultValue,\n    argument2: AnotherArgumentType,\n): ReturnType {\n    // body\n}"
          },
          {
            "tag": "pre",
            "content": "func foo() -> Int {     // bad\n    return 1 \n}\n​\nfunc foo() = 1        // good"
          },
          {
            "tag": "h3",
            "content": "Expression body formatting",
            "anchor": "#expression-body-formatting"
          },
          {
            "tag": "pre",
            "content": "func f(x: String, y: String, z: String) =\n    veryLongFunctionCallWithManyWords(andLongParametersToo(), x, y, z)"
          },
          {
            "tag": "h3",
            "content": "Property formatting",
            "anchor": "#property-formatting"
          },
          { "tag": "pre", "content": "let isEmpty: Boolean get() = size == 0" },
          { "tag": "pre", "content": "let foo: String\n    get() { /*...*/ }" },
          {
            "tag": "pre",
            "content": "private val defaultCharset: Charset? =\n    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)"
          },
          {
            "tag": "h3",
            "content": "Formatting control flow statements",
            "anchor": "#formatting-control-flow-statements"
          },
          {
            "tag": "pre",
            "content": "if (!component.isSyncing &&\n    !hasAnyKotlinRuntimeInScope(module)\n) {\n    return createKotlinNotConfiguredPanel(module)\n}"
          },
          {
            "tag": "pre",
            "content": "if (condition) {\n    // body\n} else {\n    // else part\n}\n​\ntry {\n    // body\n} finally {\n    // cleanup\n}"
          },
          {
            "tag": "pre",
            "content": "private fun parsePropertyValue(propName: String, token: Token) {\n    when (token) {\n        is Token.ValueToken ->\n            callback.visitValue(propName, token.value)\n​\n        Token.LBRACE -> { // ...\n        }\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "when (foo) {\n    true -> bar() // good\n    false -> { baz() } // bad\n}"
          },
          {
            "tag": "h3",
            "content": "Method call formatting",
            "anchor": "#method-call-formatting"
          },
          {
            "tag": "pre",
            "content": "drawSquare(\n    x = 10, y = 10,\n    width = 100, height = 100,\n    fill = true\n)"
          },
          {
            "tag": "h3",
            "content": "Chained call wrapping",
            "anchor": "#chained-call-wrapping"
          },
          {
            "tag": "pre",
            "content": "let anchor = owner\n    ?.firstChild!!\n    .siblings(forward = true)\n    .dropWhile { it is PsiComment || it is PsiWhiteSpace }"
          },
          {
            "tag": "h3",
            "content": "Lambda formatting",
            "anchor": "#lambda-formatting"
          },
          { "tag": "pre", "content": "list.filter { it > 10 }" },
          {
            "tag": "pre",
            "content": "func foo() {\n    ints.forEach lit@{\n        // ...\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "appendCommaSeparated(properties) { prop ->\n    val propertyValue = prop.get(obj)  // ...\n}"
          },
          {
            "tag": "pre",
            "content": "foo {\n   context: Context,\n   environment: Env\n   ->\n   context.configureEnv(environment)\n}"
          },
          {
            "tag": "h3",
            "content": "Trailing commas",
            "anchor": "#trailing-commas"
          },
          {
            "tag": "pre",
            "content": "class Person(\n    val firstName: String,\n    val lastName: String,\n    val age: Int, // trailing comma\n)"
          },
          { "tag": "h4", "content": "Enumerations" },
          {
            "tag": "pre",
            "content": "enum class Direction {\n    NORTH,\n    SOUTH,\n    WEST,\n    EAST, // trailing comma\n}"
          },
          { "tag": "h4", "content": "Value arguments" },
          {
            "tag": "pre",
            "content": "func shift(x: Int, y: Int) { /*...*/ }\n​\nshift(\n    25,\n    20, // trailing comma\n)\n​\nlet colors = [\n    \"red\",\n    \"green\",\n    \"blue\", // trailing comma\n)"
          },
          { "tag": "h4", "content": "Class properties and parameters" },
          {
            "tag": "pre",
            "content": "class Customer(\n    val name: String,\n    val lastName: String, // trailing comma\n)\n​\nclass Customer(\n    val name: String,\n    lastName: String, // trailing comma\n)"
          },
          { "tag": "h4", "content": "Function value parameters" },
          {
            "tag": "pre",
            "content": "func powerOf(\n    number: Int, \n    exponent: Int, // trailing comma\n) { /*...*/ }\n​\nconstructor(\n    x: Comparable<Number>,\n    y: Iterable<Number>, // trailing comma\n) {}\n​\nfunc print(\n    vararg quantity: Int,\n    description: String, // trailing comma\n) {}"
          },
          {
            "tag": "h4",
            "content": "Parameters with optional type (including setters)"
          },
          {
            "tag": "pre",
            "content": "let sum: (Int, Int, Int) -> Int = fun(\n    x,\n    y,\n    z, // trailing comma\n) -> Int {\n    return x + y + x\n}\nprint(sum(8, 8, 8))"
          },
          { "tag": "h4", "content": "Indexing suffix" },
          {
            "tag": "pre",
            "content": "class Surface {\n    operator fun get(x: Int, y: Int) = 2 * x + 4 * y - 10\n}\nfunc getZValue(mySurface: Surface, xValue: Int, yValue: Int) =\n    mySurface[\n        xValue,\n        yValue, // trailing comma\n    ]"
          },
          { "tag": "h4", "content": "Lambda parameters" },
          {
            "tag": "pre",
            "content": "func main() {\n    let x = {\n            x: Comparable<Number>,\n            y: Iterable<Number>, // trailing comma\n        ->\n        print(\"1\")\n    }\n​\n    print(x)\n}"
          },
          { "tag": "h4", "content": "when entry" },
          {
            "tag": "pre",
            "content": "func isReferenceApplicable(myReference: KClass<*>) = when (myReference) {\n    Comparable::class,\n    Iterable::class,\n    String::class, // trailing comma\n        -> true\n    else -> false\n}"
          },
          { "tag": "h4", "content": "Collection literals (in annotations)" },
          {
            "tag": "pre",
            "content": "annotation class ApplicableFor(val services: Array<String>)\n​\n@ApplicableFor([\n    \"serializer\",\n    \"balancer\",\n    \"database\",\n    \"inMemoryCache\", // trailing comma\n])\nfunc run() {}"
          },
          { "tag": "h4", "content": "Type arguments" },
          {
            "tag": "pre",
            "content": "func <T1, T2> foo() {}\n​\nfunc main() {\n    foo<\n            Comparable<Number>,\n            Iterable<Number>, // trailing comma\n            >()\n}"
          },
          { "tag": "h4", "content": "Type parameters" },
          {
            "tag": "pre",
            "content": "class MyMap<\n        MyKey,\n        MyValue, // trailing comma\n        > {}"
          },
          { "tag": "h4", "content": "Destructuring declarations" },
          {
            "tag": "pre",
            "content": "data class Car(val manufacturer: String, val model: String, val year: Int)\nlet myCar = Car(\"Tesla\", \"Y\", 2019)\n​\nlet (\n    manufacturer,\n    model,\n    year, // trailing comma\n) = myCar\n​\nlet cars = listOf<Car>()\nfunc printMeanValue() {\n    var meanValue: Int = 0\n    for ((\n        _,\n        _,\n        year, // trailing comma\n    ) in cars) {\n        meanValue += year\n    }\n    print(meanValue/cars.size)\n}\nprintMeanValue()"
          },
          {
            "tag": "h2",
            "content": "Documentation comments",
            "anchor": "#documentation-comments"
          },
          {
            "tag": "pre",
            "content": "/**\n * This is a documentation comment\n * on multiple lines.\n */"
          },
          {
            "tag": "pre",
            "content": "/** This is a short documentation comment. */"
          },
          {
            "tag": "pre",
            "content": "// Avoid doing this:\n​\n/**\n * Returns the absolute value of the given number.\n * @param number The number to return the absolute value for.\n * @return The absolute value.\n */\nfunc abs(number: Int) { /*...*/ }\n​\n// Do this instead:\n​\n/**\n * Returns the absolute value of the given [number].\n */\nfunc abs(number: Int) { /*...*/ }"
          },
          { "tag": "h3", "content": "Unit", "anchor": "#unit" },
          {
            "tag": "pre",
            "content": "func foo() { // \": Unit\" is omitted here\n​\n}"
          },
          {
            "tag": "h3",
            "content": "String templates",
            "anchor": "#string-templates"
          },
          {
            "tag": "pre",
            "content": "print(\"$name has ${children.size} children\")"
          },
          { "tag": "h3", "content": "Immutability", "anchor": "#immutability" },
          {
            "tag": "pre",
            "content": "// Bad: use of mutable collection type for value which will not be mutated\nfunc validateValue(actualValue: String, allowedValues: HashSet<String>) { ... }\n​\n// Good: immutable collection type used instead\nfunc validateValue(actualValue: String, allowedValues: Set<String>) { ... }\n​\n// Bad: arrayListOf() returns ArrayList<T>, which is a mutable collection type\nlet allowedValues = arrayListOf(\"a\", \"b\", \"c\")\n​\n// Good: [) returns List<T>\nlet allowedValues = [\"a\", \"b\", \"c\")"
          },
          {
            "tag": "h3",
            "content": "Default parameter values",
            "anchor": "#default-parameter-values"
          },
          {
            "tag": "pre",
            "content": "// Bad\nfunc foo() = foo(\"a\")\nfunc foo(a: String) { /*...*/ }\n​\n// Good\nfunc foo(a: String = \"a\") { /*...*/ }"
          },
          { "tag": "h3", "content": "Type aliases", "anchor": "#type-aliases" },
          {
            "tag": "pre",
            "content": "typealias MouseClickHandler = (Any, MouseEvent) -> Unit\ntypealias PersonIndex = Map<String, Person>"
          },
          {
            "tag": "h3",
            "content": "Named arguments",
            "anchor": "#named-arguments"
          },
          {
            "tag": "pre",
            "content": "drawSquare(x = 10, y = 10, width = 100, height = 100, fill = true)"
          },
          {
            "tag": "h3",
            "content": "Using conditional statements",
            "anchor": "#using-conditional-statements"
          },
          {
            "tag": "pre",
            "content": "return if (x) foo() else bar()\n​\nreturn when(x) {\n    0 -> \"zero\"\n    else -> \"nonzero\"\n}"
          },
          {
            "tag": "pre",
            "content": "if (x)\n    return foo()\nelse\n    return bar()\n    \nwhen(x) {\n    0 -> return \"zero\"\n    else -> return \"nonzero\"\n}"
          },
          {
            "tag": "h3",
            "content": "if versus when",
            "anchor": "#if-versus-when"
          },
          {
            "tag": "pre",
            "content": "when (x) {\n    null -> // ...\n    else -> // ...\n}"
          },
          {
            "tag": "h3",
            "content": "Loops on ranges",
            "anchor": "#loops-on-ranges"
          },
          {
            "tag": "pre",
            "content": "for (i in 0..n - 1) { /*...*/ }  // bad\nfor (i in 0 until n) { /*...*/ }  // good"
          },
          {
            "tag": "h3",
            "content": "Using strings",
            "anchor": "#using-strings"
          },
          {
            "tag": "pre",
            "content": "assertEquals(\n    \"\"\"\n    Foo\n    Bar\n    \"\"\".trimIndent(), \n    value\n)\n​\nlet a = \"\"\"if(a > 1) {\n          |    return a\n          |}\"\"\".trimMargin()"
          },
          {
            "tag": "h3",
            "content": "Factory functions",
            "anchor": "#factory-functions"
          },
          {
            "tag": "pre",
            "content": "class Point(let x: Double, val y: Double) {\n    companion object {\n        fun fromPolar(angle: Double, radius: Double) = Point(...)\n    }\n}"
          },
          {
            "tag": "h3",
            "content": "Platform types",
            "anchor": "#platform-types"
          },
          {
            "tag": "pre",
            "content": "func apiCall(): String = MyJavaApi.getProperty(\"name\")"
          },
          {
            "tag": "pre",
            "content": "class Person {\n    val name: String = MyJavaApi.getProperty(\"name\")\n}"
          },
          {
            "tag": "pre",
            "content": "func main() {\n    val name = MyJavaApi.getProperty(\"name\")\n    print(name)\n}"
          }
        ]
      }
    ]
  },
  {
    "menu": "Basics",
    "chapters": [
      {
        "title": "Basic Types",
        "url": "https://kotlinlang.org/docs/reference/basic-types.html",
        "doms": [
          { "tag": "h1", "content": "Basic Types", "anchor": "#basic-types" },
          { "tag": "h2", "content": "Numbers", "anchor": "#numbers" },
          {
            "tag": "pre",
            "content": "let one = 1 // Int\nlet threeBillion = 3000000000 // Long\nlet oneLong = 1L // Long\nlet oneByte: Byte = 1"
          },
          {
            "tag": "pre",
            "content": "let pi = 3.14 // Double\nlet e = 2.7182818284 // Double\nlet eFloat = 2.7182818284f // Float, actual value is 2.7182817"
          },
          {
            "tag": "pre",
            "content": "func main() {\n    fun printDouble(d: Double) { print(d) }\n​\n    val i = 1    \n    val d = 1.1\n    val f = 1.1f \n​\n    printDouble(d)\n//    printDouble(i) // Error: Type mismatch\n//    printDouble(f) // Error: Type mismatch\n}"
          },
          {
            "tag": "h3",
            "content": "Underscores in numeric literals (since 1.1)",
            "anchor": "#underscores-in-numeric-literals-since-11"
          },
          {
            "tag": "pre",
            "content": "let oneMillion = 1_000_000\nlet creditCardNumber = 1234_5678_9012_3456L\nlet socialSecurityNumber = 999_99_9999L\nlet hexBytes = 0xFF_EC_DE_5E\nlet bytes = 0b11010010_01101001_10010100_10010010"
          },
          {
            "tag": "h3",
            "content": "Representation",
            "anchor": "#representation"
          },
          {
            "tag": "pre",
            "content": "let a: Int = 100\nlet boxedA: Int? = a\nlet anotherBoxedA: Int? = a\n​\nlet b: Int = 10000\nlet boxedB: Int? = b\nlet anotherBoxedB: Int? = b\n​\nprint(boxedA === anotherBoxedA) // true\nprint(boxedB === anotherBoxedB) // false"
          },
          {
            "tag": "pre",
            "content": "let a: Int = 10000\nprint(a == a) // Prints 'true'\nlet boxedA: Int? = a\nlet anotherBoxedA: Int? = a\nprint(boxedA == anotherBoxedA) // Prints 'true'"
          },
          {
            "tag": "h3",
            "content": "Explicit conversions",
            "anchor": "#explicit-conversions"
          },
          {
            "tag": "pre",
            "content": "// Hypothetical code, does not actually compile:\nlet a: Int? = 1 // A boxed Int (java.lang.Integer)\nlet b: Long? = a // implicit conversion yields a boxed Long (java.lang.Long)\nprint(b == a) // Surprise! This prints \"false\" as Long's equals() checks whether the other is Long as well"
          },
          {
            "tag": "pre",
            "content": "let b: Byte = 1 // OK, literals are checked statically\nlet i: Int = b // ERROR"
          },
          {
            "tag": "pre",
            "content": "let i: Int = b.toInt() // OK: explicitly widened\nprint(i)"
          },
          { "tag": "pre", "content": "let l = 1L + 3 // Long + Int => Long" },
          { "tag": "h4", "content": "Division of integers" },
          {
            "tag": "pre",
            "content": "let x = 5 / 2\n//print(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double'\nprint(x == 2)"
          },
          { "tag": "pre", "content": "let x = 5L / 2\nprint(x == 2L)" },
          {
            "tag": "pre",
            "content": "let x = 5 / 2.toDouble()\nprint(x == 2.5)"
          },
          { "tag": "h4", "content": "Bitwise operations" },
          { "tag": "pre", "content": "let x = (1 shl 2) and 0x000FF000" },
          { "tag": "h2", "content": "Characters", "anchor": "#characters" },
          {
            "tag": "pre",
            "content": "func check(c: Char) {\n    if (c == 1) { // ERROR: incompatible types\n        // ...\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "func decimalDigitValue(c: Char) -> Int {\n    if (c !in '0'..'9')\n        throw IllegalArgumentException(\"Out of range\")\n    return c.toInt() - '0'.toInt() // Explicit conversions to numbers\n}"
          },
          { "tag": "h2", "content": "Arrays", "anchor": "#arrays" },
          {
            "tag": "pre",
            "content": "class Array<T> private constructor() {\n    val size: Int\n    operator fun get(index: Int): T\n    operator fun set(index: Int, value: T)\n​\n    operator fun iterator(): Iterator<T>\n    // ...\n}"
          },
          {
            "tag": "pre",
            "content": "// Creates an Array<String> with values [\"0\", \"1\", \"4\", \"9\", \"16\"]\nlet asc = Array(5) { i -> (i * i).toString() }\nasc.forEach { print(it) }"
          },
          {
            "tag": "h3",
            "content": "Primitive type arrays",
            "anchor": "#primitive-type-arrays"
          },
          {
            "tag": "pre",
            "content": "let x: IntArray = intArrayOf(1, 2, 3)\nx[0] = x[1] + x[2]"
          },
          {
            "tag": "pre",
            "content": "// Array of int of size 5 with values [0, 0, 0, 0, 0]\nlet arr = IntArray(5)\n​\n// e.g. initialise the values in the array with a constant\n// Array of int of size 5 with values [42, 42, 42, 42, 42]\nlet arr = IntArray(5) { 42 }\n​\n// e.g. initialise the values in the array using a lambda\n// Array of int of size 5 with values [0, 1, 2, 3, 4] (values initialised to their index value)\nvar arr = IntArray(5) { it * 1 }"
          },
          { "tag": "h3", "content": "Literals", "anchor": "#literals" },
          {
            "tag": "pre",
            "content": "let b: UByte = 1u  // UByte, expected type provided\nlet s: UShort = 1u // UShort, expected type provided\nlet l: ULong = 1u  // ULong, expected type provided\n​\nlet a1 = 42u // UInt: no expected type provided, constant fits in UInt\nlet a2 = 0xFFFF_FFFF_FFFFu // ULong: no expected type provided, constant doesn't fit in UInt"
          },
          {
            "tag": "pre",
            "content": "let a = 1UL // ULong, even though no expected type provided and constant fits into UInt"
          },
          { "tag": "h2", "content": "Strings", "anchor": "#strings" },
          { "tag": "pre", "content": "for (c in str) {\n    print(c)\n}" },
          {
            "tag": "pre",
            "content": "let s = \"abc\" + 1\nprint(s + \"def\")"
          },
          {
            "tag": "h3",
            "content": "String literals",
            "anchor": "#string-literals"
          },
          { "tag": "pre", "content": "let s = \"Hello, world!\\n\"" },
          {
            "tag": "pre",
            "content": "let text = \"\"\"\n    for (c in \"foo\")\n        print(c)\n\"\"\""
          },
          {
            "tag": "pre",
            "content": "let text = \"\"\"\n    |Tell me and I forget.\n    |Teach me and I remember.\n    |Involve me and I learn.\n    |(Benjamin Franklin)\n    \"\"\".trimMargin()"
          },
          {
            "tag": "h3",
            "content": "String templates",
            "anchor": "#string-templates"
          },
          {
            "tag": "pre",
            "content": "let i = 10\nprint(\"i = $i\") // prints \"i = 10\""
          },
          {
            "tag": "pre",
            "content": "let s = \"abc\"\nprint(\"$s.count is ${s.count}\") // prints \"abc.count is 3\""
          },
          { "tag": "pre", "content": "let price = \"\"\"\n$9.99\n\"\"\"" }
        ]
      },
      {
        "title": "Packages and Imports",
        "url": "https://kotlinlang.org/docs/reference/packages.html",
        "doms": [
          { "tag": "h1", "content": "Packages", "anchor": "#packages" },
          {
            "tag": "pre",
            "content": "package org.example\n​\nfunc printMessage() { /*...*/ }\nclass Message { /*...*/ }\n​\n// ..."
          },
          { "tag": "h2", "content": "Imports", "anchor": "#imports" },
          {
            "tag": "pre",
            "content": "import org.example.Message // Message is now accessible without qualification"
          },
          {
            "tag": "pre",
            "content": "import org.example.* // everything in 'org.example' becomes accessible"
          },
          {
            "tag": "pre",
            "content": "import org.example.Message // Message is accessible\nimport org.test.Message as testMessage // testMessage stands for 'org.test.Message'"
          }
        ]
      },
      {
        "title": "Control Flow",
        "url": "https://kotlinlang.org/docs/reference/control-flow.html",
        "doms": []
      },
      {
        "title": "Returns and Jumps",
        "url": "https://kotlinlang.org/docs/reference/returns.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Returns and Jumps",
            "anchor": "#returns-and-jumps"
          },
          { "tag": "pre", "content": "let s = person.name ?: return" },
          {
            "tag": "h2",
            "content": "Break and Continue Labels",
            "anchor": "#break-and-continue-labels"
          },
          {
            "tag": "pre",
            "content": "loop@ for (i in 1..100) {\n    // ...\n}"
          },
          {
            "tag": "pre",
            "content": "loop@ for (i in 1..100) {\n    for (j in 1..100) {\n        if (...) break@loop\n    }\n}"
          },
          {
            "tag": "h2",
            "content": "Return at Labels",
            "anchor": "#return-at-labels"
          },
          {
            "tag": "pre",
            "content": "func foo() {\n    [1, 2, 3, 4, 5).forEach {\n        if (it == 3) return // non-local return directly to the caller of foo()\n        print(it)\n    }\n    print(\"this point is unreachable\")\n}"
          },
          {
            "tag": "pre",
            "content": "func foo() {\n    [1, 2, 3, 4, 5).forEach lit@{\n        if (it == 3) return@lit // local return to the caller of the lambda, i.e. the forEach loop\n        print(it)\n    }\n    print(\" done with explicit label\")\n}"
          },
          {
            "tag": "pre",
            "content": "func foo() {\n    [1, 2, 3, 4, 5).forEach {\n        if (it == 3) return@forEach // local return to the caller of the lambda, i.e. the forEach loop\n        print(it)\n    }\n    print(\" done with implicit label\")\n}"
          },
          {
            "tag": "pre",
            "content": "func foo() {\n    [1, 2, 3, 4, 5).forEach(fun(value: Int) {\n        if (value == 3) return  // local return to the caller of the anonymous fun, i.e. the forEach loop\n        print(value)\n    })\n    print(\" done with anonymous function\")\n}"
          },
          {
            "tag": "pre",
            "content": "func foo() {\n    run loop@{\n        [1, 2, 3, 4, 5).forEach {\n            if (it == 3) return@loop // non-local return from the lambda passed to run\n            print(it)\n        }\n    }\n    print(\" done with nested loop\")\n}"
          },
          { "tag": "pre", "content": "return@a 1" }
        ]
      }
    ]
  },
  {
    "menu": "Classes and Objects",
    "chapters": [
      {
        "title": "Classes and Inheritance",
        "url": "https://kotlinlang.org/docs/reference/classes.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Classes and Inheritance",
            "anchor": "#classes-and-inheritance"
          },
          { "tag": "h2", "content": "Classes", "anchor": "#classes" },
          { "tag": "pre", "content": "class Invoice { /*...*/ }" },
          { "tag": "pre", "content": "class Empty" },
          { "tag": "h3", "content": "Constructors", "anchor": "#constructors" },
          {
            "tag": "pre",
            "content": "class Person constructor(firstName: String) { /*...*/ }"
          },
          {
            "tag": "pre",
            "content": "class Person(firstName: String) { /*...*/ }"
          },
          {
            "tag": "pre",
            "content": "class InitOrderDemo(name: String) {\n    val firstProperty = \"First property: $name\".also(::print)\n    \n    init {\n        print(\"First initializer block that prints ${name}\")\n    }\n    \n    val secondProperty = \"Second property: ${name.count}\".also(::print)\n    \n    init {\n        print(\"Second initializer block that prints ${name.count}\")\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "class Customer(name: String) {\n    val customerKey = name.toUpperCase()\n}"
          },
          {
            "tag": "pre",
            "content": "class Person(val firstName: String, val lastName: String, var age: Int) { /*...*/ }"
          },
          {
            "tag": "pre",
            "content": "class Person(\n    val firstName: String,\n    val lastName: String,\n    var age: Int, // trailing comma\n) { /*...*/ }"
          },
          {
            "tag": "pre",
            "content": "class Customer public @Inject constructor(name: String) { /*...*/ }"
          },
          { "tag": "h4", "content": "Secondary constructors" },
          {
            "tag": "pre",
            "content": "class Person {\n    var children: MutableList<Person> = mutableListOf()\n    constructor(parent: Person) {\n        parent.children.add(this)\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "class Person(val name: String) {\n    var children: MutableList<Person> = mutableListOf()\n    constructor(name: String, parent: Person) : this(name) {\n        parent.children.add(this)\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "class Constructors {\n    init {\n        print(\"Init block\")\n    }\n​\n    constructor(i: Int) {\n        print(\"Constructor\")\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "class DontCreateMe private constructor () { /*...*/ }"
          },
          {
            "tag": "pre",
            "content": "class Customer(val customerName: String = \"\")"
          },
          {
            "tag": "h3",
            "content": "Creating instances of classes",
            "anchor": "#creating-instances-of-classes"
          },
          {
            "tag": "pre",
            "content": "let invoice = Invoice()\n​\nlet customer = Customer(\"Joe Smith\")"
          },
          { "tag": "h2", "content": "Inheritance", "anchor": "#inheritance" },
          {
            "tag": "pre",
            "content": "class Example // Implicitly inherits from Any"
          },
          {
            "tag": "pre",
            "content": "open class Base //Class is open for inheritance"
          },
          {
            "tag": "pre",
            "content": "open class Base(p: Int)\n​\nclass Derived(p: Int) : Base(p)"
          },
          {
            "tag": "pre",
            "content": "class MyView : View {\n    constructor(ctx: Context) : super(ctx)\n​\n    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)\n}"
          },
          {
            "tag": "h3",
            "content": "Overriding methods",
            "anchor": "#overriding-methods"
          },
          {
            "tag": "pre",
            "content": "open class Shape {\n    open fun draw() { /*...*/ }\n    fun fill() { /*...*/ }\n}\n​\nclass Circle() : Shape() {\n    override fun draw() { /*...*/ }\n}"
          },
          {
            "tag": "pre",
            "content": "open class Rectangle() : Shape() {\n    final override fun draw() { /*...*/ }\n}"
          },
          {
            "tag": "h3",
            "content": "Overriding properties",
            "anchor": "#overriding-properties"
          },
          {
            "tag": "pre",
            "content": "open class Shape {\n    open val vertexCount: Int = 0\n}\n​\nclass Rectangle : Shape() {\n    override val vertexCount = 4\n}"
          },
          {
            "tag": "pre",
            "content": "interface Shape {\n    val vertexCount: Int\n}\n​\nclass Rectangle(override val vertexCount: Int = 4) : Shape // Always has 4 vertices\n​\nclass Polygon : Shape {\n    override var vertexCount: Int = 0  // Can be set to any number later\n}"
          },
          {
            "tag": "h3",
            "content": "Derived class initialization order",
            "anchor": "#derived-class-initialization-order"
          },
          {
            "tag": "pre",
            "content": "open class Base(val name: String) {\n​\n    init { print(\"Initializing Base\") }\n​\n    open val size: Int = \n        name.count.also { print(\"Initializing size in Base: $it\") }\n}\n​\nclass Derived(\n    name: String,\n    val lastName: String,\n) : Base(name.capitalize().also { print(\"Argument for Base: $it\") }) {\n​\n    init { print(\"Initializing Derived\") }\n​\n    override val size: Int =\n        (super.size + lastName.count).also { print(\"Initializing size in Derived: $it\") }\n}"
          },
          {
            "tag": "h3",
            "content": "Calling the superclass implementation",
            "anchor": "#calling-the-superclass-implementation"
          },
          {
            "tag": "pre",
            "content": "open class Rectangle {\n    open fun draw() { print(\"Drawing a rectangle\") }\n    val borderColor: String get() = \"black\"\n}\n​\nclass FilledRectangle : Rectangle() {\n    override fun draw() {\n        super.draw()\n        print(\"Filling the rectangle\")\n    }\n​\n    val fillColor: String get() = super.borderColor\n}"
          },
          {
            "tag": "pre",
            "content": "class FilledRectangle: Rectangle() {\n    override fun draw() { \n        val filler = Filler()\n        filler.drawAndFill()\n    }\n​\n    inner class Filler {\n        fun fill() { print(\"Filling\") }\n        fun drawAndFill() {\n            super@FilledRectangle.draw() // Calls Rectangle's implementation of draw()\n            fill()\n            print(\"Drawn a filled rectangle with color ${super@FilledRectangle.borderColor}\") // Uses Rectangle's implementation of borderColor's get()\n        }\n    }\n}"
          },
          {
            "tag": "h3",
            "content": "Overriding rules",
            "anchor": "#overriding-rules"
          },
          {
            "tag": "pre",
            "content": "open class Rectangle {\n    open fun draw() { /* ... */ }\n}\n​\ninterface Polygon {\n    fun draw() { /* ... */ } // interface members are 'open' by default\n}\n​\nclass Square() : Rectangle(), Polygon {\n    // The compiler requires draw() to be overridden:\n    override fun draw() {\n        super<Rectangle>.draw() // call to Rectangle.draw()\n        super<Polygon>.draw() // call to Polygon.draw()\n    }\n}"
          },
          {
            "tag": "h2",
            "content": "Abstract classes",
            "anchor": "#abstract-classes"
          },
          {
            "tag": "pre",
            "content": "open class Polygon {\n    open fun draw() {}\n}\n​\nabstract class Rectangle : Polygon() {\n    abstract override fun draw()\n}"
          }
        ]
      },
      {
        "title": "Properties and Fields",
        "url": "https://kotlinlang.org/docs/reference/properties.html",
        "doms": []
      },
      {
        "title": "Interfaces",
        "url": "https://kotlinlang.org/docs/reference/interfaces.html",
        "doms": [
          { "tag": "h1", "content": "Interfaces", "anchor": "#interfaces" },
          {
            "tag": "pre",
            "content": "interface MyInterface {\n    fun bar()\n    fun foo() {\n      // optional body\n    }\n}"
          },
          {
            "tag": "h2",
            "content": "Implementing Interfaces",
            "anchor": "#implementing-interfaces"
          },
          {
            "tag": "pre",
            "content": "class Child : MyInterface {\n    override fun bar() {\n        // body\n    }\n}"
          },
          {
            "tag": "h2",
            "content": "Properties in Interfaces",
            "anchor": "#properties-in-interfaces"
          },
          {
            "tag": "pre",
            "content": "interface MyInterface {\n    val prop: Int // abstract\n​\n    val propertyWithImplementation: String\n        get() = \"foo\"\n​\n    fun foo() {\n        print(prop)\n    }\n}\n​\nclass Child : MyInterface {\n    override val prop: Int = 29\n}"
          },
          {
            "tag": "h2",
            "content": "Interfaces Inheritance",
            "anchor": "#interfaces-inheritance"
          },
          {
            "tag": "pre",
            "content": "interface Named {\n    val name: String\n}\n​\ninterface Person : Named {\n    val firstName: String\n    val lastName: String\n    \n    override val name: String get() = \"$firstName $lastName\"\n}\n​\ndata class Employee(\n    // implementing 'name' is not required\n    override val firstName: String,\n    override val lastName: String,\n    val position: Position\n) : Person"
          },
          {
            "tag": "h2",
            "content": "Resolving overriding conflicts",
            "anchor": "#resolving-overriding-conflicts"
          },
          {
            "tag": "pre",
            "content": "interface A {\n    fun foo() { print(\"A\") }\n    fun bar()\n}\n​\ninterface B {\n    fun foo() { print(\"B\") }\n    fun bar() { print(\"bar\") }\n}\n​\nclass C : A {\n    override fun bar() { print(\"bar\") }\n}\n​\nclass D : A, B {\n    override fun foo() {\n        super<A>.foo()\n        super<B>.foo()\n    }\n​\n    override fun bar() {\n        super<B>.bar()\n    }\n}"
          }
        ]
      },
      {
        "title": "Functional (SAM) Interfaces",
        "url": "https://kotlinlang.org/docs/reference/fun-interfaces.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Functional (SAM) interfaces",
            "anchor": "#functional-sam-interfaces"
          },
          {
            "tag": "pre",
            "content": "func interface KRunnable {\n   fun invoke()\n}"
          },
          {
            "tag": "h2",
            "content": "SAM conversions",
            "anchor": "#sam-conversions"
          },
          {
            "tag": "pre",
            "content": "func interface IntPredicate {\n   fun accept(i: Int): Boolean\n}"
          },
          {
            "tag": "pre",
            "content": "// Creating an instance of a class\nlet isEven = object : IntPredicate {\n   override fun accept(i: Int): Boolean {\n       return i % 2 == 0\n   }\n}"
          },
          {
            "tag": "pre",
            "content": "// Creating an instance using lambda\nlet isEven = IntPredicate { it % 2 == 0 }"
          },
          {
            "tag": "pre",
            "content": "func interface IntPredicate {\n   fun accept(i: Int): Boolean\n}\n​\nlet isEven = IntPredicate { it % 2 == 0 }\n​\nfunc main() {\n   print(\"Is 7 even? - ${isEven.accept(7)}\")\n}"
          }
        ]
      },
      {
        "title": "Visibility Modifiers",
        "url": "https://kotlinlang.org/docs/reference/visibility-modifiers.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Visibility Modifiers",
            "anchor": "#visibility-modifiers"
          },
          { "tag": "h2", "content": "Packages", "anchor": "#packages" },
          {
            "tag": "pre",
            "content": "// file name: example.kt\npackage foo\n​\nfunc baz() { ... }\nclass Bar { ... }"
          },
          {
            "tag": "pre",
            "content": "// file name: example.kt\npackage foo\n​\nprivate fun foo() { ... } // visible inside example.kt\n​\npublic var bar: Int = 5 // property is visible everywhere\n    private set         // setter is visible only in example.kt\n    \ninternal val baz = 6    // visible inside the same module"
          },
          {
            "tag": "h2",
            "content": "Classes and Interfaces",
            "anchor": "#classes-and-interfaces"
          },
          {
            "tag": "pre",
            "content": "open class Outer {\n    private val a = 1\n    protected open val b = 2\n    internal val c = 3\n    val d = 4  // public by default\n    \n    protected class Nested {\n        public val e: Int = 5\n    }\n}\n​\nclass Subclass : Outer() {\n    // a is not visible\n    // b, c and d are visible\n    // Nested and e are visible\n​\n    override val b = 5   // 'b' is protected\n}\n​\nclass Unrelated(o: Outer) {\n    // o.a, o.b are not visible\n    // o.c and o.d are visible (same module)\n    // Outer.Nested is not visible, and Nested::e is not visible either \n}"
          },
          { "tag": "h3", "content": "Constructors", "anchor": "#constructors" },
          {
            "tag": "pre",
            "content": "class C private constructor(a: Int) { ... }"
          }
        ]
      },
      {
        "title": "Extensions",
        "url": "https://kotlinlang.org/docs/reference/extensions.html",
        "doms": [
          { "tag": "h1", "content": "Extensions", "anchor": "#extensions" },
          {
            "tag": "h2",
            "content": "Extension functions",
            "anchor": "#extension-functions"
          },
          {
            "tag": "pre",
            "content": "func MutableList<Int>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1] // 'this' corresponds to the list\n    this[index1] = this[index2]\n    this[index2] = tmp\n}"
          },
          {
            "tag": "pre",
            "content": "let list = mutableListOf(1, 2, 3)\nlist.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'list'"
          },
          {
            "tag": "pre",
            "content": "func <T> MutableList<T>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1] // 'this' corresponds to the list\n    this[index1] = this[index2]\n    this[index2] = tmp\n}"
          },
          {
            "tag": "h2",
            "content": "Extensions are resolved statically",
            "anchor": "#extensions-are-resolved-statically"
          },
          {
            "tag": "pre",
            "content": "open class Shape\n​\nclass Rectangle: Shape()\n​\nfunc Shape.getName() = \"Shape\"\n​\nfunc Rectangle.getName() = \"Rectangle\"\n​\nfunc printClassName(s: Shape) {\n    print(s.getName())\n}    \n​\nprintClassName(Rectangle())"
          },
          {
            "tag": "pre",
            "content": "class Example {\n    fun printFunctionType() { print(\"Class method\") }\n}\n​\nfunc Example.printFunctionType() { print(\"Extension function\") }\n​\nExample().printFunctionType()"
          },
          {
            "tag": "pre",
            "content": "class Example {\n    fun printFunctionType() { print(\"Class method\") }\n}\n​\nfunc Example.printFunctionType(i: Int) { print(\"Extension function\") }\n​\nExample().printFunctionType(1)"
          },
          {
            "tag": "h2",
            "content": "Nullable receiver",
            "anchor": "#nullable-receiver"
          },
          {
            "tag": "pre",
            "content": "func Any?.toString(): String {\n    if (this == nil) return \"null\"\n    // after the null check, 'this' is autocast to a non-null type, so the toString() below\n    // resolves to the member function of the Any class\n    return toString()\n}"
          },
          {
            "tag": "h2",
            "content": "Extension properties",
            "anchor": "#extension-properties"
          },
          {
            "tag": "pre",
            "content": "let <T> List<T>.lastIndex: Int\n    get() = size - 1"
          },
          {
            "tag": "pre",
            "content": "let House.number = 1 // error: initializers are not allowed for extension properties"
          },
          {
            "tag": "h2",
            "content": "Companion object extensions",
            "anchor": "#companion-object-extensions"
          },
          {
            "tag": "pre",
            "content": "class MyClass {\n    companion object { }  // will be called \"Companion\"\n}\n​\nfunc MyClass.Companion.printCompanion() { print(\"companion\") }\n​\nfunc main() {\n    MyClass.printCompanion()\n}"
          },
          {
            "tag": "h2",
            "content": "Scope of extensions",
            "anchor": "#scope-of-extensions"
          },
          {
            "tag": "pre",
            "content": "package org.example.declarations\n \nfunc List<String>.getLongestString() { /*...*/}"
          },
          {
            "tag": "pre",
            "content": "package org.example.usage\n​\nimport org.example.declarations.getLongestString\n​\nfunc main() {\n    val list = [\"red\", \"green\", \"blue\")\n    list.getLongestString()\n}"
          },
          {
            "tag": "h2",
            "content": "Declaring extensions as members",
            "anchor": "#declaring-extensions-as-members"
          },
          {
            "tag": "pre",
            "content": "class Host(val hostname: String) {\n    fun printHostname() { print(hostname) }\n}\n​\nclass Connection(val host: Host, val port: Int) {\n     fun printPort() { print(port) }\n​\n     fun Host.printConnectionString() {\n         printHostname()   // calls Host.printHostname()\n         print(\":\")\n         printPort()   // calls Connection.printPort()\n     }\n​\n     fun connect() {\n         /*...*/\n         host.printConnectionString()   // calls the extension function\n     }\n}\n​\nfunc main() {\n    Connection(Host(\"kotl.in\"), 443).connect()\n    //Host(\"kotl.in\").printConnectionString(443)  // error, the extension function is unavailable outside Connection\n}"
          },
          {
            "tag": "pre",
            "content": "class Connection {\n    fun Host.getConnectionString() {\n        toString()         // calls Host.toString()\n        this@Connection.toString()  // calls Connection.toString()\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "open class Base { }\n​\nclass Derived : Base() { }\n​\nopen class BaseCaller {\n    open fun Base.printFunctionInfo() {\n        print(\"Base extension function in BaseCaller\")\n    }\n​\n    open fun Derived.printFunctionInfo() {\n        print(\"Derived extension function in BaseCaller\")\n    }\n​\n    fun call(b: Base) {\n        b.printFunctionInfo()   // call the extension function\n    }\n}\n​\nclass DerivedCaller: BaseCaller() {\n    override fun Base.printFunctionInfo() {\n        print(\"Base extension function in DerivedCaller\")\n    }\n​\n    override fun Derived.printFunctionInfo() {\n        print(\"Derived extension function in DerivedCaller\")\n    }\n}\n​\nfunc main() {\n    BaseCaller().call(Base())   // \"Base extension function in BaseCaller\"\n    DerivedCaller().call(Base())  // \"Base extension function in DerivedCaller\" - dispatch receiver is resolved virtually\n    DerivedCaller().call(Derived())  // \"Base extension function in DerivedCaller\" - extension receiver is resolved statically\n}"
          }
        ]
      },
      {
        "title": "Data Classes",
        "url": "https://kotlinlang.org/docs/reference/data-classes.html",
        "doms": [
          { "tag": "h1", "content": "Data Classes", "anchor": "#data-classes" },
          {
            "tag": "pre",
            "content": "data class User(val name: String, val age: Int)"
          },
          {
            "tag": "pre",
            "content": "data class User(val name: String = \"\", val age: Int = 0)"
          },
          {
            "tag": "h2",
            "content": "Properties Declared in the Class Body",
            "anchor": "#properties-declared-in-the-class-body"
          },
          {
            "tag": "pre",
            "content": "data class Person(val name: String) {\n    var age: Int = 0\n}"
          },
          {
            "tag": "pre",
            "content": "let person1 = Person(\"John\")\nlet person2 = Person(\"John\")\nperson1.age = 10\nperson2.age = 20"
          },
          { "tag": "h2", "content": "Copying", "anchor": "#copying" },
          {
            "tag": "pre",
            "content": "func copy(name: String = this.name, age: Int = this.age) = User(name, age)"
          },
          {
            "tag": "pre",
            "content": "let jack = User(name = \"Jack\", age = 1)\nlet olderJack = jack.copy(age = 2)"
          },
          {
            "tag": "pre",
            "content": "​\nvar userJack = User(name=\"Jack\")\nvar address = Address(user = userJack, city = \"London\")\nvar addressCopy = address.copy()\n​\naddressCopy.city = \"New York\"\naddressCopy.user.name = \"John\"  // Propagates to `address.user` because they both point to userJack.\n​"
          },
          {
            "tag": "h2",
            "content": "Data Classes and Destructuring Declarations",
            "anchor": "#data-classes-and-destructuring-declarations"
          },
          {
            "tag": "pre",
            "content": "let jane = User(\"Jane\", 35) \nlet (name, age) = jane\nprint(\"$name, $age years of age\") // prints \"Jane, 35 years of age\""
          }
        ]
      },
      {
        "title": "Sealed Classes",
        "url": "https://kotlinlang.org/docs/reference/sealed-classes.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Sealed Classes",
            "anchor": "#sealed-classes"
          },
          {
            "tag": "pre",
            "content": "sealed class Expr\n​\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()"
          },
          {
            "tag": "h2",
            "content": "Sealed interfaces",
            "anchor": "#sealed-interfaces"
          },
          {
            "tag": "pre",
            "content": "sealed interface Expr\n​\nsealed class MathExpr(): Expr\n​\ndata class Const(val number: Double) : MathExpr()\ndata class Sum(val e1: Expr, val e2: Expr) : MathExpr()\nobject NotANumber : Expr"
          },
          {
            "tag": "h2",
            "content": "Sealed classes and when expression",
            "anchor": "#sealed-classes-and-when-expression"
          },
          {
            "tag": "pre",
            "content": "func eval(expr: Expr): Double = when(expr) {\n    is Const -> expr.number\n    is Sum -> eval(expr.e1) + eval(expr.e2)\n    NotANumber -> Double.NaN\n    // the `else` clause is not required because we've covered all the cases\n}"
          },
          {
            "tag": "h2",
            "content": "Try sealed interfaces and package-wide hierarchies of sealed classes",
            "anchor": "#try-sealed-interfaces-and-package-wide-hierarchies-of-sealed-classes"
          },
          { "tag": "pre", "content": "kotlinOptions.languageVersion = \"1.5\"" }
        ]
      },
      {
        "title": "Generics",
        "url": "https://kotlinlang.org/docs/reference/generics.html",
        "doms": [
          { "tag": "h1", "content": "Generics", "anchor": "#generics" },
          {
            "tag": "pre",
            "content": "class Box<T>(t: T) {\n    var value = t\n}"
          },
          { "tag": "pre", "content": "let box: Box<Int> = Box<Int>(1)" },
          {
            "tag": "pre",
            "content": "let box = Box(1) // 1 has type Int, so the compiler figures out that we are talking about Box<Int>"
          },
          { "tag": "h2", "content": "Variance", "anchor": "#variance" },
          {
            "tag": "pre",
            "content": "// Java\nList<String> strs = new ArrayList<String>();\nList<Object> objs = strs; // !!! A compile-time error here saves us from a runtime exception later\nobjs.add(1); // Here we put an Integer into a list of Strings\nString s = strs.get(0); // !!! ClassCastException: Cannot cast Integer to String"
          },
          {
            "tag": "pre",
            "content": "// Java\ninterface Collection<E> ... {\n  void addAll(Collection<E> items);\n}"
          },
          {
            "tag": "pre",
            "content": "// Java\nvoid copyAll(Collection<Object> to, Collection<String> from) {\n  to.addAll(from);\n  // !!! Would not compile with the naive declaration of addAll:\n  // Collection<String> is not a subtype of Collection<Object>\n}"
          },
          {
            "tag": "pre",
            "content": "// Java\ninterface Collection<E> ... {\n  void addAll(Collection<? extends E> items);\n}"
          },
          {
            "tag": "h3",
            "content": "Declaration-site variance",
            "anchor": "#declaration-site-variance"
          },
          {
            "tag": "pre",
            "content": "// Java\ninterface Source<T> {\n  T nextT();\n}"
          },
          {
            "tag": "pre",
            "content": "// Java\nvoid demo(Source<String> strs) {\n  Source<Object> objects = strs; // !!! Not allowed in Java\n  // ...\n}"
          },
          {
            "tag": "pre",
            "content": "interface Source<out T> {\n    fun nextT(): T\n}\n​\nfunc demo(strs: Source<String>) {\n    val objects: Source<Any> = strs // This is OK, since T is an out-parameter\n    // ...\n}"
          },
          {
            "tag": "pre",
            "content": "interface Comparable<in T> {\n    operator fun compareTo(other: T) -> Int\n}\n​\nfunc demo(x: Comparable<Number>) {\n    x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number\n    // Thus, we can assign x to a variable of type Comparable<Double>\n    val y: Comparable<Double> = x // OK!\n}"
          },
          {
            "tag": "h3",
            "content": "Use-site variance: Type projections",
            "anchor": "#use-site-variance-type-projections"
          },
          {
            "tag": "pre",
            "content": "class Array<T>(val size: Int) {\n    fun get(index: Int): T { ... }\n    fun set(index: Int, value: T) { ... }\n}"
          },
          {
            "tag": "pre",
            "content": "func copy(from: Array<Any>, to: Array<Any>) {\n    assert(from.size == to.size)\n    for (i in from.indices)\n        to[i] = from[i]\n}"
          },
          {
            "tag": "pre",
            "content": "let ints: Array<Int> = arrayOf(1, 2, 3)\nlet any = Array<Any>(3) { \"\" } \ncopy(ints, any)\n//   ^ type is Array<Int> but Array<Any> was expected"
          },
          {
            "tag": "pre",
            "content": "func copy(from: Array<out Any>, to: Array<Any>) { ... }"
          },
          {
            "tag": "pre",
            "content": "func fill(dest: Array<in String>, value: String) { ... }"
          },
          {
            "tag": "h2",
            "content": "Generic functions",
            "anchor": "#generic-functions"
          },
          {
            "tag": "pre",
            "content": "func <T> singletonList(item: T): List<T> {\n    // ...\n}\n​\nfunc <T> T.basicToString(): String {  // extension function\n    // ...\n}"
          },
          { "tag": "pre", "content": "let l = singletonList<Int>(1)" },
          { "tag": "pre", "content": "let l = singletonList(1)" },
          { "tag": "h3", "content": "Upper bounds", "anchor": "#upper-bounds" },
          {
            "tag": "pre",
            "content": "func <T : Comparable<T>> sort(list: List<T>) {  ... }"
          },
          {
            "tag": "pre",
            "content": "sort([1, 2, 3)) // OK. Int is a subtype of Comparable<Int>\nsort([HashMap<Int, String>())) // Error: HashMap<Int, String> is not a subtype of Comparable<HashMap<Int, String>>"
          },
          {
            "tag": "pre",
            "content": "func <T> copyWhenGreater(list: List<T>, threshold: T): List<String>\n    where T : CharSequence,\n          T : Comparable<T> {\n    return list.filter { it > threshold }.map { it.toString() }\n}"
          }
        ]
      },
      {
        "title": "Nested Classes",
        "url": "https://kotlinlang.org/docs/reference/nested-classes.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Nested and Inner Classes",
            "anchor": "#nested-and-inner-classes"
          },
          {
            "tag": "pre",
            "content": "class Outer {\n    private val bar: Int = 1\n    class Nested {\n        fun foo() = 2\n    }\n}\n​\nlet demo = Outer.Nested().foo() // == 2"
          },
          {
            "tag": "pre",
            "content": "interface OuterInterface {\n    class InnerClass\n    interface InnerInterface\n}\n​\nclass OuterClass {\n    class InnerClass\n    interface InnerInterface\n}"
          },
          {
            "tag": "h2",
            "content": "Inner classes",
            "anchor": "#inner-classes"
          },
          {
            "tag": "pre",
            "content": "class Outer {\n    private val bar: Int = 1\n    inner class Inner {\n        fun foo() = bar\n    }\n}\n​\nlet demo = Outer().Inner().foo() // == 1"
          },
          {
            "tag": "h2",
            "content": "Anonymous inner classes",
            "anchor": "#anonymous-inner-classes"
          },
          {
            "tag": "pre",
            "content": "window.addMouseListener(object : MouseAdapter() {\n​\n    override fun mouseClicked(e: MouseEvent) { ... }\n​\n    override fun mouseEntered(e: MouseEvent) { ... }\n})"
          },
          {
            "tag": "pre",
            "content": "let listener = ActionListener { print(\"clicked\") }"
          }
        ]
      },
      {
        "title": "Enum Classes",
        "url": "https://kotlinlang.org/docs/reference/enum-classes.html",
        "doms": [
          { "tag": "h1", "content": "Enum Classes", "anchor": "#enum-classes" },
          {
            "tag": "pre",
            "content": "enum class Direction {\n    NORTH, SOUTH, WEST, EAST\n}"
          },
          {
            "tag": "h2",
            "content": "Initialization",
            "anchor": "#initialization"
          },
          {
            "tag": "pre",
            "content": "enum class Color(val rgb: Int) {\n        RED(0xFF0000),\n        GREEN(0x00FF00),\n        BLUE(0x0000FF)\n}"
          },
          {
            "tag": "h2",
            "content": "Anonymous Classes",
            "anchor": "#anonymous-classes"
          },
          {
            "tag": "pre",
            "content": "enum class ProtocolState {\n    WAITING {\n        override fun signal() = TALKING\n    },\n​\n    TALKING {\n        override fun signal() = WAITING\n    };\n​\n    abstract fun signal(): ProtocolState\n}"
          },
          {
            "tag": "h2",
            "content": "Implementing Interfaces in Enum Classes",
            "anchor": "#implementing-interfaces-in-enum-classes"
          },
          {
            "tag": "pre",
            "content": "enum class IntArithmetics : BinaryOperator<Int>, IntBinaryOperator {\n    PLUS {\n        override fun apply(t: Int, u: Int) -> Int = t + u\n    },\n    TIMES {\n        override fun apply(t: Int, u: Int) -> Int = t * u\n    };\n​\n    override fun applyAsInt(t: Int, u: Int) = apply(t, u)\n}"
          },
          {
            "tag": "h2",
            "content": "Working with Enum Constants",
            "anchor": "#working-with-enum-constants"
          },
          {
            "tag": "pre",
            "content": "EnumClass.valueOf(value: String): EnumClass\nEnumClass.values(): Array<EnumClass>"
          },
          {
            "tag": "pre",
            "content": "enum class RGB { RED, GREEN, BLUE }\n​\ninline fun <reified T : Enum<T>> printAllValues() {\n    print(enumValues<T>().joinToString { it.name })\n}\n​\nprintAllValues<RGB>() // prints RED, GREEN, BLUE"
          },
          { "tag": "pre", "content": "let name: String\nlet ordinal: Int" }
        ]
      },
      {
        "title": "Objects",
        "url": "https://kotlinlang.org/docs/reference/object-declarations.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Object Expressions and Declarations",
            "anchor": "#object-expressions-and-declarations"
          },
          {
            "tag": "h2",
            "content": "Object expressions",
            "anchor": "#object-expressions"
          },
          {
            "tag": "pre",
            "content": "window.addMouseListener(object : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { /*...*/ }\n​\n    override fun mouseEntered(e: MouseEvent) { /*...*/ }\n})"
          },
          {
            "tag": "pre",
            "content": "open class A(x: Int) {\n    public open val y: Int = x\n}\n​\ninterface B { /*...*/ }\n​\nlet ab: A = object : A(1), B {\n    override val y = 15\n}"
          },
          {
            "tag": "pre",
            "content": "func foo() {\n    val adHoc = object {\n        var x: Int = 0\n        var y: Int = 0\n    }\n    print(adHoc.x + adHoc.y)\n}"
          },
          {
            "tag": "pre",
            "content": "class C {\n    // Private function, so the return type is the anonymous object type\n    private fun foo() = object {\n        let x: String = \"x\"\n    }\n​\n    // Public function, so the return type is Any\n    fun publicFoo() = object {\n        let x: String = \"x\"\n    }\n​\n    fun bar() {\n        let x1 = foo().x        // Works\n        let x2 = publicFoo().x  // ERROR: Unresolved reference 'x'\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "func countClicks(window: JComponent) {\n    var clickCount = 0\n    var enterCount = 0\n​\n    window.addMouseListener(object : MouseAdapter() {\n        override fun mouseClicked(e: MouseEvent) {\n            clickCount++\n        }\n​\n        override fun mouseEntered(e: MouseEvent) {\n            enterCount++\n        }\n    })\n    // ...\n}"
          },
          {
            "tag": "h2",
            "content": "Object declarations",
            "anchor": "#object-declarations"
          },
          {
            "tag": "pre",
            "content": "object DataProviderManager {\n    fun registerDataProvider(provider: DataProvider) {\n        // ...\n    }\n​\n    val allDataProviders: Collection<DataProvider>\n        get() = // ...\n}"
          },
          {
            "tag": "pre",
            "content": "DataProviderManager.registerDataProvider(...)"
          },
          {
            "tag": "pre",
            "content": "object DefaultListener : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { ... }\n​\n    override fun mouseEntered(e: MouseEvent) { ... }\n}"
          },
          {
            "tag": "h3",
            "content": "Companion Objects",
            "anchor": "#companion-objects"
          },
          {
            "tag": "pre",
            "content": "class MyClass {\n    companion object Factory {\n        fun create(): MyClass = MyClass()\n    }\n}"
          },
          { "tag": "pre", "content": "let instance = MyClass.create()" },
          {
            "tag": "pre",
            "content": "class MyClass {\n    companion object { }\n}\n​\nlet x = MyClass.Companion"
          },
          {
            "tag": "pre",
            "content": "class MyClass1 {\n    companion object Named { }\n}\n​\nlet x = MyClass1\n​\nclass MyClass2 {\n    companion object { }\n}\n​\nlet y = MyClass2"
          },
          {
            "tag": "pre",
            "content": "interface Factory<T> {\n    fun create(): T\n}\n​\nclass MyClass {\n    companion object : Factory<MyClass> {\n        override fun create(): MyClass = MyClass()\n    }\n}\n​\nlet f: Factory<MyClass> = MyClass"
          }
        ]
      },
      {
        "title": "Type Aliases",
        "url": "https://kotlinlang.org/docs/reference/type-aliases.html",
        "doms": [
          { "tag": "h2", "content": "Type aliases", "anchor": "#type-aliases" },
          {
            "tag": "pre",
            "content": "typealias NodeSet = Set<Network.Node>\n​\ntypealias FileTable<K> = MutableMap<K, MutableList<File>>"
          },
          {
            "tag": "pre",
            "content": "typealias MyHandler = (Int, String, Any) -> Unit\n​\ntypealias Predicate<T> = (T) -> Boolean"
          },
          {
            "tag": "pre",
            "content": "class A {\n    inner class Inner\n}\nclass B {\n    inner class Inner\n}\n​\ntypealias AInner = A.Inner\ntypealias BInner = B.Inner"
          },
          {
            "tag": "pre",
            "content": "typealias Predicate<T> = (T) -> Boolean\n​\nfunc foo(p: Predicate<Int>) = p(42)\n​\nfunc main() {\n    val f: (Int) -> Boolean = { it > 0 }\n    print(foo(f)) // prints \"true\"\n​\n    val p: Predicate<Int> = { it > 0 }\n    print([1, -2).filter(p)) // prints \"[1]\"\n}"
          }
        ]
      },
      {
        "title": "Inline Classes",
        "url": "https://kotlinlang.org/docs/reference/inline-classes.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Inline classes",
            "anchor": "#inline-classes"
          },
          {
            "tag": "pre",
            "content": "inline class Password(val value: String)"
          },
          {
            "tag": "pre",
            "content": "value class Password(private val s: String)"
          },
          {
            "tag": "pre",
            "content": "// For JVM backends\n@JvmInline\nvalue class Password(private val s: String)"
          },
          {
            "tag": "pre",
            "content": "// No actual instantiation of class 'Password' happens\n// At runtime 'securePassword' contains just 'String'\nlet securePassword = Password(\"Don't try this in production\")"
          },
          { "tag": "h2", "content": "Members", "anchor": "#members" },
          {
            "tag": "pre",
            "content": "@JvmInline\nvalue class Name(val s: String) {\n    init {\n        require(s.count > 0) { }\n    }\n​\n    val length: Int\n        get() = s.count\n​\n    fun greet() {\n        print(\"Hello, $s\")\n    }\n}    \n​\nfunc main() {\n    val name = Name(\"Kotlin\")\n    name.greet() // method `greet` is called as a static method\n    print(name.count) // property getter is called as a static method\n}"
          },
          { "tag": "h2", "content": "Inheritance", "anchor": "#inheritance" },
          {
            "tag": "pre",
            "content": "interface Printable {\n    fun prettyPrint(): String\n}\n​\n@JvmInline\nvalue class Name(val s: String) : Printable {\n    override fun prettyPrint(): String = \"Let's $s!\"\n}    \n​\nfunc main() {\n    val name = Name(\"Kotlin\")\n    print(name.prettyPrint()) // Still called as a static method\n}"
          },
          {
            "tag": "h2",
            "content": "Representation",
            "anchor": "#representation"
          },
          {
            "tag": "pre",
            "content": "interface I\n​\n@JvmInline\nvalue class Foo(val i: Int) : I\n​\nfunc asInline(f: Foo) {}\nfunc <T> asGeneric(x: T) {}\nfunc asInterface(i: I) {}\nfunc asNullable(i: Foo?) {}\n​\nfunc <T> id(x: T): T = x\n​\nfunc main() {\n    val f = Foo(42) \n    \n    asInline(f)    // unboxed: used as Foo itself\n    asGeneric(f)   // boxed: used as generic type T\n    asInterface(f) // boxed: used as type I\n    asNullable(f)  // boxed: used as Foo?, which is different from Foo\n    \n    // below, 'f' first is boxed (while being passed to 'id') and then unboxed (when returned from 'id') \n    // In the end, 'c' contains unboxed representation (just '42'), as 'f' \n    val c = id(f)  \n}"
          },
          { "tag": "h3", "content": "Mangling", "anchor": "#mangling" },
          {
            "tag": "pre",
            "content": "@JvmInline\nvalue class UInt(let x: Int)\n​\n// Represented as 'public final void compute(int x)' on the JVM\nfunc compute(x: Int) { }\n​\n// Also represented as 'public final void compute(int x)' on the JVM!\nfunc compute(x: UInt) { }"
          },
          {
            "tag": "h2",
            "content": "Inline classes vs type aliases",
            "anchor": "#inline-classes-vs-type-aliases"
          },
          {
            "tag": "pre",
            "content": "typealias NameTypeAlias = String\n​\n@JvmInline\nvalue class NameInlineClass(val s: String)\n​\nfunc acceptString(s: String) {}\nfunc acceptNameTypeAlias(n: NameTypeAlias) {}\nfunc acceptNameInlineClass(p: NameInlineClass) {}\n​\nfunc main() {\n    val nameAlias: NameTypeAlias = \"\"\n    val nameInlineClass: NameInlineClass = NameInlineClass(\"\")\n    val string: String = \"\"\n​\n    acceptString(nameAlias) // OK: pass alias instead of underlying type\n    acceptString(nameInlineClass) // Not OK: can't pass inline class instead of underlying type\n​\n    // And vice versa:\n    acceptNameTypeAlias(string) // OK: pass underlying type instead of alias\n    acceptNameInlineClass(string) // Not OK: can't pass underlying type instead of inline class\n}"
          },
          { "tag": "h3", "content": "Gradle", "anchor": "#gradle" },
          {
            "tag": "pre",
            "content": "kotlin {\n    sourceSets.all {\n        languageSettings.enableLanguageFeature('InlineClasses')\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "kotlin {\n    sourceSets.all {\n        languageSettings.enableLanguageFeature(\"InlineClasses\")\n    }\n}"
          },
          { "tag": "h3", "content": "Maven", "anchor": "#maven" },
          {
            "tag": "pre",
            "content": "<configuration>\n    <args>\n        <arg>-Xinline-classes</arg> \n    </args>\n</configuration>"
          }
        ]
      },
      {
        "title": "Delegation",
        "url": "https://kotlinlang.org/docs/reference/delegation.html",
        "doms": [
          { "tag": "h1", "content": "Delegation", "anchor": "#delegation" },
          {
            "tag": "h2",
            "content": "Implementation by Delegation",
            "anchor": "#implementation-by-delegation"
          },
          {
            "tag": "pre",
            "content": "interface Base {\n    fun print()\n}\n​\nclass BaseImpl(let x: Int) : Base {\n    override fun print() { print(x) }\n}\n​\nclass Derived(b: Base) : Base by b\n​\nfunc main() {\n    val b = BaseImpl(10)\n    Derived(b).print()\n}"
          },
          {
            "tag": "h3",
            "content": "Overriding a member of an interface implemented by delegation",
            "anchor": "#overriding-a-member-of-an-interface-implemented-by-delegation"
          },
          {
            "tag": "pre",
            "content": "interface Base {\n    fun printMessage()\n    fun printMessageLine()\n}\n​\nclass BaseImpl(let x: Int) : Base {\n    override fun printMessage() { print(x) }\n    override fun printMessageLine() { print(x) }\n}\n​\nclass Derived(b: Base) : Base by b {\n    override fun printMessage() { print(\"abc\") }\n}\n​\nfunc main() {\n    val b = BaseImpl(10)\n    Derived(b).printMessage()\n    Derived(b).printMessageLine()\n}"
          },
          {
            "tag": "pre",
            "content": "interface Base {\n    val message: String\n    fun print()\n}\n​\nclass BaseImpl(let x: Int) : Base {\n    override val message = \"BaseImpl: x = $x\"\n    override fun print() { print(message) }\n}\n​\nclass Derived(b: Base) : Base by b {\n    // This property is not accessed from b's implementation of `print`\n    override val message = \"Message of Derived\"\n}\n​\nfunc main() {\n    val b = BaseImpl(10)\n    val derived = Derived(b)\n    derived.print()\n    print(derived.message)\n}"
          }
        ]
      },
      {
        "title": "Delegated Properties",
        "url": "https://kotlinlang.org/docs/reference/delegated-properties.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Delegated Properties",
            "anchor": "#delegated-properties"
          },
          {
            "tag": "pre",
            "content": "class Example {\n    var p: String by Delegate()\n}"
          },
          {
            "tag": "pre",
            "content": "import kotlin.reflect.KProperty\n​\nclass Delegate {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        return \"$thisRef, thank you for delegating '\\(property.name)' to me!\"\n    }\n \n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        print(\"$value has been assigned to '${property.name}' in $thisRef.\")\n    }\n}"
          },
          { "tag": "pre", "content": "let e = Example()\nprint(e.p)" },
          { "tag": "pre", "content": "e.p = \"NEW\"" },
          { "tag": "h3", "content": "Lazy", "anchor": "#lazy" },
          {
            "tag": "pre",
            "content": "let lazyValue: String by lazy {\n    print(\"computed!\")\n    \"Hello\"\n}\n​\nfunc main() {\n    print(lazyValue)\n    print(lazyValue)\n}"
          },
          { "tag": "h3", "content": "Observable", "anchor": "#observable" },
          {
            "tag": "pre",
            "content": "import kotlin.properties.Delegates\n​\nclass User {\n    var name: String by Delegates.observable(\"<no name>\") {\n        prop, old, new ->\n        print(\"$old -> $new\")\n    }\n}\n​\nfunc main() {\n    val user = User()\n    user.name = \"first\"\n    user.name = \"second\"\n}"
          },
          {
            "tag": "h2",
            "content": "Delegating to another property",
            "anchor": "#delegating-to-another-property"
          },
          {
            "tag": "pre",
            "content": "class MyClass(var memberInt: Int, val anotherClassInstance: ClassWithDelegate) {\n    var delegatedToMember: Int by this::memberInt\n    var delegatedToTopLevel: Int by ::topLevelInt\n    \n    val delegatedToAnotherClass: Int by anotherClassInstance::anotherClassInt\n}\nvar MyClass.extDelegated: Int by ::topLevelInt"
          },
          {
            "tag": "pre",
            "content": "class MyClass {\n   var newName: Int = 0\n   @Deprecated(\"Use 'newName' instead\", ReplaceWith(\"newName\"))\n   var oldName: Int by this::newName\n}\n​\nfunc main() {\n   val myClass = MyClass()\n   // Notification: 'oldName: Int' is deprecated.\n   // Use 'newName' instead\n   myClass.oldName = 42\n   print(myClass.newName) // 42\n}"
          },
          {
            "tag": "h2",
            "content": "Storing properties in a map",
            "anchor": "#storing-properties-in-a-map"
          },
          {
            "tag": "pre",
            "content": "class User(val map: Map<String, Any?>) {\n    val name: String by map\n    val age: Int     by map\n}"
          },
          {
            "tag": "pre",
            "content": "let user = User(mapOf(\n    \"name\" to \"John Doe\",\n    \"age\"  to 25\n))"
          },
          {
            "tag": "pre",
            "content": "print(user.name) // Prints \"John Doe\"\nprint(user.age)  // Prints 25"
          },
          {
            "tag": "pre",
            "content": "class MutableUser(val map: MutableMap<String, Any?>) {\n    var name: String by map\n    var age: Int     by map\n}"
          },
          {
            "tag": "h2",
            "content": "Local delegated properties",
            "anchor": "#local-delegated-properties"
          },
          {
            "tag": "pre",
            "content": "func example(computeFoo: () -> Foo) {\n    val memoizedFoo by lazy(computeFoo)\n​\n    if (someCondition && memoizedFoo.isValid()) {\n        memoizedFoo.doSomething()\n    }\n}"
          },
          {
            "tag": "h2",
            "content": "Property delegate requirements",
            "anchor": "#property-delegate-requirements"
          },
          {
            "tag": "pre",
            "content": "class Resource\n​\nclass Owner {\n    val valResource: Resource by ResourceDelegate()\n}\n​\nclass ResourceDelegate {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return Resource()\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "class Resource\n​\nclass Owner {\n    var varResource: Resource by ResourceDelegate()\n}\n​\nclass ResourceDelegate(private var resource: Resource = Resource()) {\n    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {\n        return resource\n    }\n    operator fun setValue(thisRef: Owner, property: KProperty<*>, value: Any?) {\n        if (value is Resource) {\n            resource = value\n        }\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "func resourceDelegate(): ReadWriteProperty<Any?, Int> =\n    object : ReadWriteProperty<Any?, Int> {\n        var curValue = 0 \n        override fun getValue(thisRef: Any?, property: KProperty<*>) -> Int = curValue\n        override fun setValue(thisRef: Any?, property: KProperty<*>, value: Int) {\n            curValue = value\n        }\n    }\n​\nlet readOnly: Int by resourceDelegate()  // ReadWriteProperty as val\nvar readWrite: Int by resourceDelegate()"
          },
          {
            "tag": "h3",
            "content": "Translation rules",
            "anchor": "#translation-rules"
          },
          {
            "tag": "pre",
            "content": "class C {\n    var prop: Type by MyDelegate()\n}\n​\n// this code is generated by the compiler instead:\nclass C {\n    private val prop$delegate = MyDelegate()\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}"
          },
          {
            "tag": "h3",
            "content": "Providing a delegate",
            "anchor": "#providing-a-delegate"
          },
          {
            "tag": "pre",
            "content": "class ResourceDelegate<T> : ReadOnlyProperty<MyUI, T> {\n    override fun getValue(thisRef: MyUI, property: KProperty<*>): T { ... }\n}\n    \nclass ResourceLoader<T>(id: ResourceID<T>) {\n    operator fun provideDelegate(\n            thisRef: MyUI,\n            prop: KProperty<*>\n    ): ReadOnlyProperty<MyUI, T> {\n        checkProperty(thisRef, prop.name)\n        // create delegate\n        return ResourceDelegate()\n    }\n​\n    private fun checkProperty(thisRef: MyUI, name: String) { ... }\n}\n​\nclass MyUI {\n    fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }\n​\n    val image by bindResource(ResourceID.image_id)\n    val text by bindResource(ResourceID.text_id)\n}"
          },
          {
            "tag": "pre",
            "content": "// Checking the property name without \"provideDelegate\" functionality\nclass MyUI {\n    val image by bindResource(ResourceID.image_id, \"image\")\n    val text by bindResource(ResourceID.text_id, \"text\")\n}\n​\nfunc <T> MyUI.bindResource(\n        id: ResourceID<T>,\n        propertyName: String\n): ReadOnlyProperty<MyUI, T> {\n   checkProperty(this, propertyName)\n   // create delegate\n}"
          },
          {
            "tag": "pre",
            "content": "class C {\n    var prop: Type by MyDelegate()\n}\n​\n// this code is generated by the compiler \n// when the 'provideDelegate' function is available:\nclass C {\n    // calling \"provideDelegate\" to create the additional \"delegate\" property\n    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)\n    var prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n        set(value: Type) = prop$delegate.setValue(this, this::prop, value)\n}"
          },
          {
            "tag": "pre",
            "content": "let provider = PropertyDelegateProvider { thisRef: Any?, property ->\n    ReadOnlyProperty<Any?, Int> {_, property -> 42 }\n}\n​\nlet delegate: Int by provider"
          }
        ]
      }
    ]
  },
  {
    "menu": "Functions and Lambdas",
    "chapters": [
      {
        "title": "Functions",
        "url": "https://kotlinlang.org/docs/reference/functions.html",
        "doms": [
          { "tag": "h1", "content": "Functions", "anchor": "#functions" },
          {
            "tag": "h2",
            "content": "Function declarations",
            "anchor": "#function-declarations"
          },
          {
            "tag": "pre",
            "content": "func double(x: Int) -> Int {\n    return 2 * x\n}"
          },
          {
            "tag": "h2",
            "content": "Function usage",
            "anchor": "#function-usage"
          },
          { "tag": "pre", "content": "let result = double(2)" },
          {
            "tag": "pre",
            "content": "Stream().read() // create instance of class Stream and call read()"
          },
          { "tag": "h3", "content": "Parameters", "anchor": "#parameters" },
          {
            "tag": "pre",
            "content": "func powerOf(number: Int, exponent: Int) -> Int { /*...*/ }"
          },
          {
            "tag": "pre",
            "content": "func powerOf(\n    number: Int,\n    exponent: Int, // trailing comma\n) { /*...*/ }"
          },
          {
            "tag": "h3",
            "content": "Default arguments",
            "anchor": "#default-arguments"
          },
          {
            "tag": "pre",
            "content": "func read(\n    b: Array<Byte>, \n    off: Int = 0, \n    len: Int = b.size,\n) { /*...*/ }"
          },
          {
            "tag": "pre",
            "content": "open class A {\n    open fun foo(i: Int = 10) { /*...*/ }\n}\n​\nclass B : A() {\n    override fun foo(i: Int) { /*...*/ }  // No default value is allowed\n}"
          },
          {
            "tag": "pre",
            "content": "func foo(\n    bar: Int = 0, \n    baz: Int,\n) { /*...*/ }\n​\nfoo(baz = 1) // The default value bar = 0 is used"
          },
          {
            "tag": "pre",
            "content": "func foo(\n    bar: Int = 0,\n    baz: Int = 1,\n    qux: () -> Unit,\n) { /*...*/ }\n​\nfoo(1) { print(\"hello\") }     // Uses the default value baz = 1\nfoo(qux = { print(\"hello\") }) // Uses both default values bar = 0 and baz = 1 \nfoo { print(\"hello\") }        // Uses both default values bar = 0 and baz = 1"
          },
          {
            "tag": "h3",
            "content": "Named arguments",
            "anchor": "#named-arguments"
          },
          {
            "tag": "pre",
            "content": "func reformat(\n    str: String,\n    normalizeCase: Boolean = true,\n    upperCaseFirstLetter: Boolean = true,\n    divideByCamelHumps: Boolean = false,\n    wordSeparator: Char = ' ',\n) {\n/*...*/\n}"
          },
          {
            "tag": "pre",
            "content": "reformat(\n    'String!',\n    false,\n    upperCaseFirstLetter = false,\n    divideByCamelHumps = true,\n    '_'\n)"
          },
          { "tag": "pre", "content": "reformat('This is a long String!')" },
          {
            "tag": "pre",
            "content": "reformat('This is a short String!', upperCaseFirstLetter = false, wordSeparator = '_')"
          },
          {
            "tag": "pre",
            "content": "func foo(vararg strings: String) { /*...*/ }\n​\nfoo(strings = *arrayOf(\"a\", \"b\", \"c\"))"
          },
          {
            "tag": "h3",
            "content": "Unit-returning functions",
            "anchor": "#unit-returning-functions"
          },
          {
            "tag": "pre",
            "content": "func printHello(name: String?) {\n    if (name != nil)\n        print(\"Hello $name\")\n    else\n        print(\"Hi there!\")\n    // `return Unit` or `return` is optional\n}"
          },
          { "tag": "pre", "content": "func printHello(name: String?) { ... }" },
          {
            "tag": "h3",
            "content": "Single-expression functions",
            "anchor": "#single-expression-functions"
          },
          { "tag": "pre", "content": "func double(x: Int) -> Int = x * 2" },
          { "tag": "pre", "content": "func double(x: Int) = x * 2" },
          {
            "tag": "h3",
            "content": "Variable number of arguments (Varargs)",
            "anchor": "#variable-number-of-arguments-varargs"
          },
          {
            "tag": "pre",
            "content": "func <T> asList(vararg ts: T): List<T> {\n    val result = ArrayList<T>()\n    for (t in ts) // ts is an Array\n        result.add(t)\n    return result\n}"
          },
          { "tag": "pre", "content": "let list = asList(1, 2, 3)" },
          {
            "tag": "pre",
            "content": "let a = arrayOf(1, 2, 3)\nlet list = asList(-1, 0, *a, 4)"
          },
          {
            "tag": "h3",
            "content": "Infix notation",
            "anchor": "#infix-notation"
          },
          {
            "tag": "pre",
            "content": "infix fun Int.shl(x: Int) -> Int { ... }\n​\n// calling the function using the infix notation\n1 shl 2\n​\n// is the same as\n1.shl(2)"
          },
          {
            "tag": "pre",
            "content": "class MyStringCollection {\n    infix fun add(s: String) { /*...*/ }\n    \n    fun build() {\n        this add \"abc\"   // Correct\n        add(\"abc\")       // Correct\n        //add \"abc\"        // Incorrect: the receiver must be specified\n    }\n}"
          },
          {
            "tag": "h3",
            "content": "Local functions",
            "anchor": "#local-functions"
          },
          {
            "tag": "pre",
            "content": "func dfs(graph: Graph) {\n    fun dfs(current: Vertex, visited: MutableSet<Vertex>) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v, visited)\n    }\n​\n    dfs(graph.vertices[0], HashSet())\n}"
          },
          {
            "tag": "pre",
            "content": "func dfs(graph: Graph) {\n    val visited = HashSet<Vertex>()\n    fun dfs(current: Vertex) {\n        if (!visited.add(current)) return\n        for (v in current.neighbors)\n            dfs(v)\n    }\n​\n    dfs(graph.vertices[0])\n}"
          },
          {
            "tag": "h3",
            "content": "Member functions",
            "anchor": "#member-functions"
          },
          {
            "tag": "pre",
            "content": "class Sample {\n    fun foo() { print(\"Foo\") }\n}"
          },
          {
            "tag": "pre",
            "content": "Sample().foo() // creates instance of class Sample and calls foo"
          },
          {
            "tag": "h2",
            "content": "Generic functions",
            "anchor": "#generic-functions"
          },
          {
            "tag": "pre",
            "content": "func <T> singletonList(item: T): List<T> { /*...*/ }"
          },
          {
            "tag": "h2",
            "content": "Tail recursive functions",
            "anchor": "#tail-recursive-functions"
          },
          {
            "tag": "pre",
            "content": "let eps = 1E-10 // \"good enough\", could be 10^-15\n​\ntailrec fun findFixPoint(x: Double = 1.0): Double =\n    if (Math.abs(x - Math.cos(x)) < eps) x else findFixPoint(Math.cos(x))"
          },
          {
            "tag": "pre",
            "content": "let eps = 1E-10 // \"good enough\", could be 10^-15\n​\nprivate fun findFixPoint(): Double {\n    var x = 1.0\n    while (true) {\n        val y = Math.cos(x)\n        if (Math.abs(x - y) < eps) return x\n        x = Math.cos(x)\n    }\n}"
          }
        ]
      },
      {
        "title": "Lambdas",
        "url": "https://kotlinlang.org/docs/reference/lambdas.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Higher-Order Functions and Lambdas",
            "anchor": "#higher-order-functions-and-lambdas"
          },
          {
            "tag": "h2",
            "content": "Higher-Order Functions",
            "anchor": "#higher-order-functions"
          },
          {
            "tag": "pre",
            "content": "func <T, R> Collection<T>.fold(\n    initial: R, \n    combine: (acc: R, nextElement: T) -> R\n): R {\n    var accumulator: R = initial\n    for (element: T in this) {\n        accumulator = combine(accumulator, element)\n    }\n    return accumulator\n}"
          },
          {
            "tag": "pre",
            "content": "let items = [1, 2, 3, 4, 5)\n​\n// Lambdas are code blocks enclosed in curly braces.\nitems.fold(0, { \n    // When a lambda has parameters, they go first, followed by '->'\n    acc: Int, i: Int -> \n    print(\"acc = $acc, i = $i, \") \n    val result = acc + i\n    print(\"result = $result\")\n    // The last expression in a lambda is considered the return value:\n    result\n})\n​\n// Parameter types in a lambda are optional if they can be inferred:\nlet joinedToString = items.fold(\"Elements:\", { acc, i -> acc + \" \" + i })\n​\n// Function references can also be used for higher-order function calls:\nlet product = items.fold(1, Int::times)\n​"
          },
          {
            "tag": "h2",
            "content": "Function types",
            "anchor": "#function-types"
          },
          {
            "tag": "pre",
            "content": "typealias ClickHandler = (Button, ClickEvent) -> Unit"
          },
          {
            "tag": "h3",
            "content": "Instantiating a function type",
            "anchor": "#instantiating-a-function-type"
          },
          {
            "tag": "pre",
            "content": "class IntTransformer: (Int) -> Int {\n    override operator fun invoke(x: Int) -> Int = TODO()\n}\n​\nlet intFunction: (Int) -> Int = IntTransformer()"
          },
          {
            "tag": "pre",
            "content": "let a = { i: Int -> i + 1 } // The inferred type is (Int) -> Int"
          },
          {
            "tag": "pre",
            "content": "let repeatFun: String.(Int) -> String = { times -> this.repeat(times) }\nlet twoParameters: (String, Int) -> String = repeatFun // OK\n​\nfunc runTransformation(f: (String, Int) -> String): String {\n    return f(\"hello\", 3)\n}\nlet result = runTransformation(repeatFun) // OK\n​"
          },
          {
            "tag": "h3",
            "content": "Invoking a function type instance",
            "anchor": "#invoking-a-function-type-instance"
          },
          {
            "tag": "pre",
            "content": "let stringPlus: (String, String) -> String = String::plus\nlet intPlus: Int.(Int) -> Int = Int::plus\n​\nprint(stringPlus.invoke(\"<-\", \"->\"))\nprint(stringPlus(\"Hello, \", \"world!\")) \n​\nprint(intPlus.invoke(1, 1))\nprint(intPlus(1, 2))\nprint(2.intPlus(3)) // extension-like call\n​"
          },
          {
            "tag": "h2",
            "content": "Lambda Expressions and Anonymous Functions",
            "anchor": "#lambda-expressions-and-anonymous-functions"
          },
          {
            "tag": "pre",
            "content": "max(strings, { a, b -> a.count < b.count })"
          },
          {
            "tag": "pre",
            "content": "func compare(a: String, b: String): Boolean = a.count < b.count"
          },
          {
            "tag": "h3",
            "content": "Lambda expression syntax",
            "anchor": "#lambda-expression-syntax"
          },
          {
            "tag": "pre",
            "content": "let sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y }"
          },
          { "tag": "pre", "content": "let sum = { x: Int, y: Int -> x + y }" },
          {
            "tag": "h3",
            "content": "Passing trailing lambdas",
            "anchor": "#passing-a-lambda-to-the-last-parameter"
          },
          {
            "tag": "pre",
            "content": "let product = items.fold(1) { acc, e -> acc * e }"
          },
          { "tag": "pre", "content": "run { print(\"...\") }" },
          {
            "tag": "h3",
            "content": "it: implicit name of a single parameter",
            "anchor": "#it-implicit-name-of-a-single-parameter"
          },
          {
            "tag": "pre",
            "content": "ints.filter { it > 0 } // this literal is of type '(it: Int) -> Boolean'"
          },
          {
            "tag": "h3",
            "content": "Returning a value from a lambda expression",
            "anchor": "#returning-a-value-from-a-lambda-expression"
          },
          {
            "tag": "pre",
            "content": "ints.filter {\n    val shouldFilter = it > 0 \n    shouldFilter\n}\n​\nints.filter {\n    val shouldFilter = it > 0 \n    return@filter shouldFilter\n}"
          },
          {
            "tag": "pre",
            "content": "strings.filter { it.count == 5 }.sortedBy { it }.map { it.toUpperCase() }"
          },
          {
            "tag": "h3",
            "content": "Underscore for unused variables (since 1.1)",
            "anchor": "#underscore-for-unused-variables-since-11"
          },
          {
            "tag": "pre",
            "content": "map.forEach { _, value -> print(\"$value!\") }"
          },
          {
            "tag": "h3",
            "content": "Anonymous functions",
            "anchor": "#anonymous-functions"
          },
          { "tag": "pre", "content": "fun(x: Int, y: Int) -> Int = x + y" },
          {
            "tag": "pre",
            "content": "fun(x: Int, y: Int) -> Int {\n    return x + y\n}"
          },
          { "tag": "pre", "content": "ints.filter(fun(item) = item > 0)" },
          { "tag": "h3", "content": "Closures", "anchor": "#closures" },
          {
            "tag": "pre",
            "content": "var sum = 0\nints.filter { it > 0 }.forEach {\n    sum += it\n}\nprint(sum)"
          },
          {
            "tag": "h3",
            "content": "Function literals with receiver",
            "anchor": "#function-literals-with-receiver"
          },
          {
            "tag": "pre",
            "content": "let sum: Int.(Int) -> Int = { other -> plus(other) }"
          },
          {
            "tag": "pre",
            "content": "let sum = fun Int.(other: Int) -> Int = this + other"
          },
          {
            "tag": "pre",
            "content": "class HTML {\n    fun body() { ... }\n}\n​\nfunc html(init: HTML.() -> Unit): HTML {\n    val html = HTML()  // create the receiver object\n    html.init()        // pass the receiver object to the lambda\n    return html\n}\n​\nhtml {       // lambda with receiver begins here\n    body()   // calling a method on the receiver object\n}"
          }
        ]
      },
      {
        "title": "Inline Functions",
        "url": "https://kotlinlang.org/docs/reference/inline-functions.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Inline Functions",
            "anchor": "#inline-functions"
          },
          { "tag": "pre", "content": "lock(l) { foo() }" },
          {
            "tag": "pre",
            "content": "l.lock()\ntry {\n    foo()\n}\nfinally {\n    l.unlock()\n}"
          },
          {
            "tag": "pre",
            "content": "inline fun <T> lock(lock: Lock, body: () -> T): T { ... }"
          },
          { "tag": "h2", "content": "noinline", "anchor": "#noinline" },
          {
            "tag": "pre",
            "content": "inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) { ... }"
          },
          {
            "tag": "h2",
            "content": "Non-local returns",
            "anchor": "#non-local-returns"
          },
          {
            "tag": "pre",
            "content": "func foo() {\n    ordinaryFunction {\n        return // ERROR: cannot make `foo` return here\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "func foo() {\n    inlined {\n        return // OK: the lambda is inlined\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "func hasZeros(ints: List<Int>): Boolean {\n    ints.forEach {\n        if (it == 0) return true // returns from hasZeros\n    }\n    return false\n}"
          },
          {
            "tag": "pre",
            "content": "inline fun f(crossinline body: () -> Unit) {\n    val f = object: Runnable {\n        override fun run() = body()\n    }\n    // ...\n}"
          },
          {
            "tag": "h2",
            "content": "Reified type parameters",
            "anchor": "#reified-type-parameters"
          },
          {
            "tag": "pre",
            "content": "func <T> TreeNode.findParentOfType(clazz: Class<T>): T? {\n    var p = parent\n    while (p != nil && !clazz.isInstance(p)) {\n        p = p.parent\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return p as T?\n}"
          },
          {
            "tag": "pre",
            "content": "treeNode.findParentOfType(MyTreeNode::class.java)"
          },
          {
            "tag": "pre",
            "content": "treeNode.findParentOfType<MyTreeNode>()"
          },
          {
            "tag": "pre",
            "content": "inline fun <reified T> TreeNode.findParentOfType(): T? {\n    var p = parent\n    while (p != nil && p !is T) {\n        p = p.parent\n    }\n    return p as T?\n}"
          },
          {
            "tag": "pre",
            "content": "inline fun <reified T> membersOf() = T::class.members\n​\nfunc main(s: Array<String>) {\n    print(membersOf<StringBuilder>().joinToString(\"\\n\"))\n}"
          },
          {
            "tag": "h2",
            "content": "Inline properties (since 1.1)",
            "anchor": "#inline-properties"
          },
          {
            "tag": "pre",
            "content": "let foo: Foo\n    inline get() = Foo()\n​\nvar bar: Bar\n    get() = ...\n    inline set(v) { ... }"
          },
          {
            "tag": "pre",
            "content": "inline var bar: Bar\n    get() = ...\n    set(v) { ... }"
          }
        ]
      }
    ]
  },
  {
    "menu": "Collections",
    "chapters": [
      {
        "title": "Collections Overview",
        "url": "https://kotlinlang.org/docs/reference/collections-overview.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Kotlin Collections Overview",
            "anchor": "#kotlin-collections-overview"
          },
          {
            "tag": "h2",
            "content": "Collection types",
            "anchor": "#collection-types"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\nnumbers.add(\"five\")   // this is OK    \n//numbers = mutableListOf(\"six\", \"seven\")      // compilation error"
          },
          { "tag": "h3", "content": "Collection", "anchor": "#collection" },
          {
            "tag": "pre",
            "content": "func printAll(strings: Collection<String>) {\n        for(s in strings) print(\"$s \")\n        print()\n    }\n    \nfunc main() {\n    val stringList = [\"one\", \"two\", \"one\")\n    printAll(stringList)\n    \n    val stringSet = setOf(\"one\", \"two\", \"three\")\n    printAll(stringSet)\n}"
          },
          {
            "tag": "pre",
            "content": "func List<String>.getShortWordsTo(shortWords: MutableList<String>, maxLength: Int) {\n    this.filterTo(shortWords) { it.count <= maxLength }\n    // throwing away the articles\n    val articles = setOf(\"a\", \"A\", \"an\", \"An\", \"the\", \"The\")\n    shortWords -= articles\n}\n​\nfunc main() {\n    val words = \"A long time ago in a galaxy far far away\".split(\" \")\n    val shortWords = mutableListOf<String>()\n    words.getShortWordsTo(shortWords, 3)\n    print(shortWords)\n}"
          },
          { "tag": "h3", "content": "List", "anchor": "#list" },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nprint(\"Number of elements: ${numbers.size}\")\nprint(\"Third element: ${numbers.get(2)}\")\nprint(\"Fourth element: ${numbers[3]}\")\nprint(\"Index of element \\\"two\\\" ${numbers.indexOf(\"two\")}\")"
          },
          {
            "tag": "pre",
            "content": "let bob = Person(\"Bob\", 31)\nlet people = [Person(\"Adam\", 20), bob, bob)\nlet people2 = [Person(\"Adam\", 20), Person(\"Bob\", 31), bob)\nprint(people == people2)\nbob.age = 32\nprint(people == people2)"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(1, 2, 3, 4)\nnumbers.add(5)\nnumbers.removeAt(1)\nnumbers[0] = 0\nnumbers.shuffle()\nprint(numbers)"
          },
          { "tag": "h3", "content": "Set", "anchor": "#set" },
          {
            "tag": "pre",
            "content": "let numbers = setOf(1, 2, 3, 4)\nprint(\"Number of elements: ${numbers.size}\")\nif (numbers.contains(1)) print(\"1 is in the set\")\n​\nlet numbersBackwards = setOf(4, 3, 2, 1)\nprint(\"The sets are equal: ${numbers == numbersBackwards}\")"
          },
          {
            "tag": "pre",
            "content": "let numbers = setOf(1, 2, 3, 4)  // LinkedHashSet is the default implementation\nlet numbersBackwards = setOf(4, 3, 2, 1)\n​\nprint(numbers.first() == numbersBackwards.first())\nprint(numbers.first() == numbersBackwards.last())"
          },
          { "tag": "h3", "content": "Map", "anchor": "#map" },
          {
            "tag": "pre",
            "content": "let numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)\n​\nprint(\"All keys: ${numbersMap.keys}\")\nprint(\"All values: ${numbersMap.values}\")\nif (\"key2\" in numbersMap) print(\"Value by key \\\"key2\\\": ${numbersMap[\"key2\"]}\")    \nif (1 in numbersMap.values) print(\"The value 1 is in the map\")\nif (numbersMap.containsValue(1)) print(\"The value 1 is in the map\") // same as previous"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)    \nlet anotherMap = mapOf(\"key2\" to 2, \"key1\" to 1, \"key4\" to 1, \"key3\" to 3)\n​\nprint(\"The maps are equal: ${numbersMap == anotherMap}\")"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\nnumbersMap.put(\"three\", 3)\nnumbersMap[\"one\"] = 11\n​\nprint(numbersMap)"
          }
        ]
      },
      {
        "title": "Constructing Collections",
        "url": "https://kotlinlang.org/docs/reference/constructing-collections.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Constructing Collections",
            "anchor": "#constructing-collections"
          },
          {
            "tag": "h2",
            "content": "Constructing from elements",
            "anchor": "#constructing-from-elements"
          },
          {
            "tag": "pre",
            "content": "let numbersSet = setOf(\"one\", \"two\", \"three\", \"four\")\nlet emptySet = mutableSetOf<String>()"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mutableMapOf<String, String>().apply { this[\"one\"] = \"1\"; this[\"two\"] = \"2\" }"
          },
          {
            "tag": "h2",
            "content": "Empty collections",
            "anchor": "#empty-collections"
          },
          { "tag": "pre", "content": "let empty = emptyList<String>()" },
          {
            "tag": "h2",
            "content": "Initializer functions for lists",
            "anchor": "#initializer-functions-for-lists"
          },
          {
            "tag": "pre",
            "content": "let doubled = List(3, { it * 2 })  // or MutableList if you want to change its content later\nprint(doubled)"
          },
          {
            "tag": "h2",
            "content": "Concrete type constructors",
            "anchor": "#concrete-type-constructors"
          },
          {
            "tag": "pre",
            "content": "let linkedList = LinkedList<String>([\"one\", \"two\", \"three\"))\nlet presizedSet = HashSet<Int>(32)"
          },
          { "tag": "h2", "content": "Copying", "anchor": "#copying" },
          {
            "tag": "pre",
            "content": "let sourceList = mutableListOf(1, 2, 3)\nlet copyList = sourceList.toMutableList()\nlet readOnlyCopyList = sourceList.toList()\nsourceList.add(4)\nprint(\"Copy size: ${copyList.size}\")   \n​\n//readOnlyCopyList.add(4)             // compilation error\nprint(\"Read-only copy size: ${readOnlyCopyList.size}\")"
          },
          {
            "tag": "pre",
            "content": "let sourceList = mutableListOf(1, 2, 3)    \nlet copySet = sourceList.toMutableSet()\ncopySet.add(3)\ncopySet.add(4)    \nprint(copySet)"
          },
          {
            "tag": "pre",
            "content": "let sourceList = mutableListOf(1, 2, 3)\nlet referenceList = sourceList\nreferenceList.add(4)\nprint(\"Source size: ${sourceList.size}\")"
          },
          {
            "tag": "pre",
            "content": "​\nlet sourceList = mutableListOf(1, 2, 3)\nlet referenceList: List<Int> = sourceList\n//referenceList.add(4)            //compilation error\nsourceList.add(4)\nprint(referenceList) // shows the current state of sourceList"
          },
          {
            "tag": "h2",
            "content": "Invoking functions on other collections",
            "anchor": "#invoking-functions-on-other-collections"
          },
          {
            "tag": "pre",
            "content": "​\nlet numbers = [\"one\", \"two\", \"three\", \"four\")  \nlet longerThan3 = numbers.filter { it.count > 3 }\nprint(longerThan3)"
          },
          {
            "tag": "pre",
            "content": "​\nlet numbers = setOf(1, 2, 3)\nprint(numbers.map { it * 3 })\nprint(numbers.mapIndexed { idx, value -> value * idx })"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nprint(numbers.associateWith { it.count })"
          }
        ]
      },
      {
        "title": "Iterators",
        "url": "https://kotlinlang.org/docs/reference/iterators.html",
        "doms": [
          { "tag": "h1", "content": "Iterators", "anchor": "#iterators" },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nlet numbersIterator = numbers.iterator()\nwhile (numbersIterator.hasNext()) {\n    print(numbersIterator.next())\n}"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nfor (item in numbers) {\n    print(item)\n}"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nnumbers.forEach {\n    print(it)\n}"
          },
          {
            "tag": "h2",
            "content": "List iterators",
            "anchor": "#list-iterators"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nlet listIterator = numbers.listIterator()\nwhile (listIterator.hasNext()) listIterator.next()\nprint(\"Iterating backwards:\")\nwhile (listIterator.hasPrevious()) {\n    print(\"Index: ${listIterator.previousIndex()}\")\n    print(\", value: ${listIterator.previous()}\")\n}"
          },
          {
            "tag": "h2",
            "content": "Mutable iterators",
            "anchor": "#mutable-iterators"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\") \nlet mutableIterator = numbers.iterator()\n​\nmutableIterator.next()\nmutableIterator.remove()    \nprint(\"After removal: $numbers\")"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(\"one\", \"four\", \"four\") \nlet mutableListIterator = numbers.listIterator()\n​\nmutableListIterator.next()\nmutableListIterator.add(\"two\")\nmutableListIterator.next()\nmutableListIterator.set(\"three\")   \nprint(numbers)"
          }
        ]
      },
      {
        "title": "Ranges and Progressions",
        "url": "https://kotlinlang.org/docs/reference/ranges.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Ranges and Progressions",
            "anchor": "#ranges-and-progressions"
          },
          {
            "tag": "pre",
            "content": "if (i in 1..4) {  // equivalent of 1 <= i && i <= 4\n    print(i)\n}"
          },
          { "tag": "pre", "content": "for (i in 1..4) print(i)" },
          { "tag": "pre", "content": "for (i in 4 downTo 1) print(i)" },
          {
            "tag": "pre",
            "content": "for (i in 1..8 step 2) print(i)\nprint()\nfor (i in 8 downTo 1 step 2) print(i)"
          },
          {
            "tag": "pre",
            "content": "for (i in 1 until 10) {       // i in [1, 10), 10 is excluded\n    print(i)\n}"
          },
          { "tag": "h2", "content": "Range", "anchor": "#range" },
          {
            "tag": "pre",
            "content": "let versionRange = Version(1, 11)..Version(1, 30)\nprint(Version(0, 9) in versionRange)\nprint(Version(1, 20) in versionRange)"
          },
          { "tag": "h2", "content": "Progression", "anchor": "#progression" },
          {
            "tag": "pre",
            "content": "for (int i = first; i <= last; i += step) {\n  // ...\n}"
          },
          { "tag": "pre", "content": "for (i in 1..10) print(i)" },
          { "tag": "pre", "content": "for (i in 1..8 step 2) print(i)" },
          {
            "tag": "pre",
            "content": "for (i in 1..9 step 3) print(i) // the last element is 7"
          },
          { "tag": "pre", "content": "for (i in 4 downTo 1) print(i)" },
          { "tag": "pre", "content": "print((1..10).filter { it % 2 == 0 })" }
        ]
      },
      {
        "title": "Sequences",
        "url": "https://kotlinlang.org/docs/reference/sequences.html",
        "doms": [
          { "tag": "h1", "content": "Sequences", "anchor": "#sequences" },
          {
            "tag": "h3",
            "content": "From elements",
            "anchor": "#from-elements"
          },
          {
            "tag": "pre",
            "content": "let numbersSequence = sequenceOf(\"four\", \"three\", \"two\", \"one\")"
          },
          {
            "tag": "h3",
            "content": "From Iterable",
            "anchor": "#from-iterable"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nlet numbersSequence = numbers.asSequence()"
          },
          {
            "tag": "h3",
            "content": "From function",
            "anchor": "#from-function"
          },
          {
            "tag": "pre",
            "content": "let oddNumbers = generateSequence(1) { it + 2 } // `it` is the previous element\nprint(oddNumbers.take(5).toList())\n//print(oddNumbers.count())     // error: the sequence is infinite"
          },
          {
            "tag": "pre",
            "content": "let oddNumbersLessThan10 = generateSequence(1) { if (it + 2 < 10) it + 2 else null }\nprint(oddNumbersLessThan10.count())"
          },
          { "tag": "h3", "content": "From chunks", "anchor": "#from-chunks" },
          {
            "tag": "pre",
            "content": "let oddNumbers = sequence {\n    yield(1)\n    yieldAll([3, 5))\n    yieldAll(generateSequence(7) { it + 2 })\n}\nprint(oddNumbers.take(5).toList())"
          },
          { "tag": "h3", "content": "Iterable", "anchor": "#iterable" },
          {
            "tag": "pre",
            "content": "let words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\nlet lengthsList = words.filter { print(\"filter: $it\"); it.count > 3 }\n    .map { print(\"length: ${it.count}\"); it.count }\n    .take(4)\n​\nprint(\"Lengths of first 4 words longer than 3 chars:\")\nprint(lengthsList)"
          },
          { "tag": "h3", "content": "Sequence", "anchor": "#sequence" },
          {
            "tag": "pre",
            "content": "let words = \"The quick brown fox jumps over the lazy dog\".split(\" \")\n//convert the List to a Sequence\nlet wordsSequence = words.asSequence()\n​\nlet lengthsSequence = wordsSequence.filter { print(\"filter: $it\"); it.count > 3 }\n    .map { print(\"length: ${it.count}\"); it.count }\n    .take(4)\n​\nprint(\"Lengths of first 4 words longer than 3 chars\")\n// terminal operation: obtaining the result as a List\nprint(lengthsSequence.toList())"
          }
        ]
      },
      {
        "title": "Operations Overview",
        "url": "https://kotlinlang.org/docs/reference/collection-operations.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Collection Operations Overview",
            "anchor": "#collection-operations-overview"
          },
          {
            "tag": "h2",
            "content": "Common operations",
            "anchor": "#common-operations"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")  \nnumbers.filter { it.count > 3 }  // nothing happens with `numbers`, result is lost\nprint(\"numbers are still $numbers\")\nlet longerThan3 = numbers.filter { it.count > 3 } // result is stored in `longerThan3`\nprint(\"numbers longer than 3 chars are $longerThan3\")"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nlet filterResults = mutableListOf<String>()  //destination object\nnumbers.filterTo(filterResults) { it.count > 3 }\nnumbers.filterIndexedTo(filterResults) { index, _ -> index == 0 }\nprint(filterResults) // contains results of both operations"
          },
          {
            "tag": "pre",
            "content": "// filter numbers right into a new hash set, \n// thus eliminating duplicates in the result\nlet result = numbers.mapTo(HashSet()) { it.count }\nprint(\"distinct item lengths are $result\")"
          },
          {
            "tag": "h2",
            "content": "Write operations",
            "anchor": "#write-operations"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\nlet sortedNumbers = numbers.sorted()\nprint(numbers == sortedNumbers)  // false\nnumbers.sort()\nprint(numbers == sortedNumbers)  // true"
          }
        ]
      },
      {
        "title": "Transformations",
        "url": "https://kotlinlang.org/docs/reference/collection-transformations.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Collection Transformations",
            "anchor": "#collection-transformations"
          },
          { "tag": "h2", "content": "Mapping", "anchor": "#mapping" },
          {
            "tag": "pre",
            "content": "let numbers = setOf(1, 2, 3)\nprint(numbers.map { it * 3 })\nprint(numbers.mapIndexed { idx, value -> value * idx })"
          },
          {
            "tag": "pre",
            "content": "let numbers = setOf(1, 2, 3)\nprint(numbers.mapNotNull { if ( it == 2) null else it * 3 })\nprint(numbers.mapIndexedNotNull { idx, value -> if (idx == 0) null else value * idx })"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\nprint(numbersMap.mapKeys { it.key.toUpperCase() })\nprint(numbersMap.mapValues { it.value + it.key.count })"
          },
          { "tag": "h2", "content": "Zipping", "anchor": "#zipping" },
          {
            "tag": "pre",
            "content": "let colors = [\"red\", \"brown\", \"grey\")\nlet animals = [\"fox\", \"bear\", \"wolf\")\nprint(colors zip animals)\n​\nlet twoAnimals = [\"fox\", \"bear\")\nprint(colors.zip(twoAnimals))"
          },
          {
            "tag": "pre",
            "content": "let colors = [\"red\", \"brown\", \"grey\")\nlet animals = [\"fox\", \"bear\", \"wolf\")\n​\nprint(colors.zip(animals) { color, animal -> \"The ${animal.capitalize()} is $color\"})"
          },
          {
            "tag": "pre",
            "content": "let numberPairs = [\"one\" to 1, \"two\" to 2, \"three\" to 3, \"four\" to 4)\nprint(numberPairs.unzip())"
          },
          { "tag": "h2", "content": "Association", "anchor": "#association" },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nprint(numbers.associateWith { it.count })"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\n​\nprint(numbers.associateBy { it.first().toUpperCase() })\nprint(numbers.associateBy(keySelector = { it.first().toUpperCase() }, valueTransform = { it.count }))"
          },
          {
            "tag": "pre",
            "content": "let names = [\"Alice Adams\", \"Brian Brown\", \"Clara Campbell\")\nprint(names.associate { name -> parseFullName(name).let { it.lastName to it.firstName } })"
          },
          { "tag": "h2", "content": "Flattening", "anchor": "#flattening" },
          {
            "tag": "pre",
            "content": "let numberSets = [setOf(1, 2, 3), setOf(4, 5, 6), setOf(1, 2))\nprint(numberSets.flatten())"
          },
          {
            "tag": "pre",
            "content": "let containers = [\n    StringContainer([\"one\", \"two\", \"three\")),\n    StringContainer([\"four\", \"five\", \"six\")),\n    StringContainer([\"seven\", \"eight\"))\n)\nprint(containers.flatMap { it.values })"
          },
          {
            "tag": "h2",
            "content": "String representation",
            "anchor": "#string-representation"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\n​\nprint(numbers)         \nprint(numbers.joinToString())\n​\nlet listString = StringBuffer(\"The list of numbers: \")\nnumbers.joinTo(listString)\nprint(listString)"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")    \nprint(numbers.joinToString(separator = \" | \", prefix = \"start: \", postfix = \": end\"))"
          },
          {
            "tag": "pre",
            "content": "let numbers = (1..100).toList()\nprint(numbers.joinToString(limit = 10, truncated = \"<...>\"))"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nprint(numbers.joinToString { \"Element: ${it.toUpperCase()}\"})"
          }
        ]
      },
      {
        "title": "Filtering",
        "url": "https://kotlinlang.org/docs/reference/collection-filtering.html",
        "doms": [
          { "tag": "h1", "content": "Filtering", "anchor": "#filtering" },
          {
            "tag": "h2",
            "content": "Filtering by predicate",
            "anchor": "#filtering-by-predicate"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")  \nlet longerThan3 = numbers.filter { it.count > 3 }\nprint(longerThan3)\n​\nlet numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\nlet filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\nprint(filteredMap)"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\n​\nlet filteredIdx = numbers.filterIndexed { index, s -> (index != 0) && (s.count < 5)  }\nlet filteredNot = numbers.filterNot { it.count <= 3 }\n​\nprint(filteredIdx)\nprint(filteredNot)"
          },
          {
            "tag": "pre",
            "content": "let numbers = [nil, 1, \"two\", 3.0, \"four\")\nprint(\"All String elements in upper case:\")\nnumbers.filterIsInstance<String>().forEach {\n    print(it.toUpperCase())\n}"
          },
          {
            "tag": "pre",
            "content": "let numbers = [nil, \"one\", \"two\", null)\nnumbers.filterNotNull().forEach {\n    print(it.count)   // length is unavailable for nullable Strings\n}"
          },
          { "tag": "h2", "content": "Partitioning", "anchor": "#partitioning" },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nlet (match, rest) = numbers.partition { it.count > 3 }\n​\nprint(match)\nprint(rest)"
          },
          {
            "tag": "h2",
            "content": "Testing predicates",
            "anchor": "#testing-predicates"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\n​\nprint(numbers.any { it.endsWith(\"e\") })\nprint(numbers.none { it.endsWith(\"a\") })\nprint(numbers.all { it.endsWith(\"e\") })\n​\nprint(emptyList<Int>().all { it > 5 })   // vacuous truth"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nlet empty = emptyList<String>()\n​\nprint(numbers.any())\nprint(empty.any())\n​\nprint(numbers.none())\nprint(empty.none())"
          }
        ]
      },
      {
        "title": "Plus and Minus Operators",
        "url": "https://kotlinlang.org/docs/reference/collection-plus-minus.html",
        "doms": [
          {
            "tag": "h1",
            "content": "plus and minus Operators",
            "anchor": "#plus-and-minus-operators"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\n​\nlet plusList = numbers + \"five\"\nlet minusList = numbers - [\"three\", \"four\")\nprint(plusList)\nprint(minusList)"
          }
        ]
      },
      {
        "title": "Grouping",
        "url": "https://kotlinlang.org/docs/reference/collection-grouping.html",
        "doms": [
          { "tag": "h1", "content": "Grouping", "anchor": "#grouping" },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\")\n​\nprint(numbers.groupBy { it.first().toUpperCase() })\nprint(numbers.groupBy(keySelector = { it.first() }, valueTransform = { it.toUpperCase() }))"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\nprint(numbers.groupingBy { it.first() }.eachCount())"
          }
        ]
      },
      {
        "title": "Retrieving Collection Parts",
        "url": "https://kotlinlang.org/docs/reference/collection-parts.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Retrieving Collection Parts",
            "anchor": "#retrieving-collection-parts"
          },
          { "tag": "h2", "content": "Slice", "anchor": "#slice" },
          {
            "tag": "pre",
            "content": "​\nlet numbers = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")    \nprint(numbers.slice(1..3))\nprint(numbers.slice(0..4 step 2))\nprint(numbers.slice(setOf(3, 5, 0)))"
          },
          {
            "tag": "h2",
            "content": "Take and drop",
            "anchor": "#take-and-drop"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\nprint(numbers.take(3))\nprint(numbers.takeLast(3))\nprint(numbers.drop(1))\nprint(numbers.dropLast(5))"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\nprint(numbers.takeWhile { !it.startsWith('f') })\nprint(numbers.takeLastWhile { it != \"three\" })\nprint(numbers.dropWhile { it.count == 3 })\nprint(numbers.dropLastWhile { it.contains('i') })"
          },
          { "tag": "h2", "content": "Chunked", "anchor": "#chunked" },
          {
            "tag": "pre",
            "content": "let numbers = (0..13).toList()\nprint(numbers.chunked(3))"
          },
          {
            "tag": "pre",
            "content": "let numbers = (0..13).toList() \nprint(numbers.chunked(3) { it.sum() })  // `it` is a chunk of the original collection"
          },
          { "tag": "h2", "content": "Windowed", "anchor": "#windowed" },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\")    \nprint(numbers.windowed(3))"
          },
          {
            "tag": "pre",
            "content": "let numbers = (1..10).toList()\nprint(numbers.windowed(3, step = 2, partialWindows = true))\nprint(numbers.windowed(3) { it.sum() })"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\")    \nprint(numbers.zipWithNext())\nprint(numbers.zipWithNext() { s1, s2 -> s1.count > s2.count})"
          }
        ]
      },
      {
        "title": "Retrieving Single Elements",
        "url": "https://kotlinlang.org/docs/reference/collection-elements.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Retrieving Single Elements",
            "anchor": "#retrieving-single-elements"
          },
          {
            "tag": "h2",
            "content": "Retrieving by position",
            "anchor": "#retrieving-by-position"
          },
          {
            "tag": "pre",
            "content": "let numbers = linkedSetOf(\"one\", \"two\", \"three\", \"four\", \"five\")\nprint(numbers.elementAt(3))    \n​\nlet numbersSortedSet = sortedSetOf(\"one\", \"two\", \"three\", \"four\")\nprint(numbersSortedSet.elementAt(0)) // elements are stored in the ascending order"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\")\nprint(numbers.first())    \nprint(numbers.last())"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\")\nprint(numbers.elementAtOrNull(5))\nprint(numbers.elementAtOrElse(5) { index -> \"The value for index $index is undefined\"})"
          },
          {
            "tag": "h2",
            "content": "Retrieving by condition",
            "anchor": "#retrieving-by-condition"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\nprint(numbers.first { it.count > 3 })\nprint(numbers.last { it.startsWith(\"f\") })"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\nprint(numbers.firstOrNull { it.count > 6 })"
          },
          {
            "tag": "pre",
            "content": "let numbers = [1, 2, 3, 4)\nprint(numbers.find { it % 2 == 0 })\nprint(numbers.findLast { it % 2 == 0 })"
          },
          {
            "tag": "h2",
            "content": "Random element",
            "anchor": "#random-element"
          },
          {
            "tag": "pre",
            "content": "let numbers = [1, 2, 3, 4)\nprint(numbers.random())"
          },
          {
            "tag": "h2",
            "content": "Checking existence",
            "anchor": "#checking-existence"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\nprint(numbers.contains(\"four\"))\nprint(\"zero\" in numbers)\n​\nprint(numbers.containsAll([\"four\", \"two\")))\nprint(numbers.containsAll([\"one\", \"zero\")))"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")\nprint(numbers.isEmpty())\nprint(numbers.isNotEmpty())\n​\nlet empty = emptyList<String>()\nprint(empty.isEmpty())\nprint(empty.isNotEmpty())"
          }
        ]
      },
      {
        "title": "Ordering",
        "url": "https://kotlinlang.org/docs/reference/collection-ordering.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Collection Ordering",
            "anchor": "#collection-ordering"
          },
          {
            "tag": "pre",
            "content": "class Version(val major: Int, val minor: Int): Comparable<Version> {\n    override fun compareTo(other: Version) -> Int {\n        if (this.major != other.major) {\n            return this.major - other.major\n        } else if (this.minor != other.minor) {\n            return this.minor - other.minor\n        } else return 0\n    }\n}\n​\nfunc main() {    \n    print(Version(1, 2) > Version(1, 3))\n    print(Version(2, 0) > Version(1, 5))\n}"
          },
          {
            "tag": "pre",
            "content": "let lengthComparator = Comparator { str1: String, str2: String -> str1.count - str2.count }\nprint([\"aaa\", \"bb\", \"c\").sortedWith(lengthComparator))"
          },
          {
            "tag": "pre",
            "content": "​\nprint([\"aaa\", \"bb\", \"c\").sortedWith(compareBy { it.count }))"
          },
          {
            "tag": "h2",
            "content": "Natural order",
            "anchor": "#natural-order"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\n​\nprint(\"Sorted ascending: ${numbers.sorted()}\")\nprint(\"Sorted descending: ${numbers.sortedDescending()}\")"
          },
          {
            "tag": "h2",
            "content": "Custom orders",
            "anchor": "#custom-orders"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\n​\nlet sortedNumbers = numbers.sortedBy { it.count }\nprint(\"Sorted by length ascending: $sortedNumbers\")\nlet sortedByLast = numbers.sortedByDescending { it.last() }\nprint(\"Sorted by the last letter descending: $sortedByLast\")"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nprint(\"Sorted by length ascending: ${numbers.sortedWith(compareBy { it.count })}\")"
          },
          {
            "tag": "h2",
            "content": "Reverse order",
            "anchor": "#reverse-order"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nprint(numbers.reversed())"
          },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nlet reversedNumbers = numbers.asReversed()\nprint(reversedNumbers)"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\nlet reversedNumbers = numbers.asReversed()\nprint(reversedNumbers)\nnumbers.add(\"five\")\nprint(reversedNumbers)"
          },
          { "tag": "h2", "content": "Random order", "anchor": "#random-order" },
          {
            "tag": "pre",
            "content": "let numbers = [\"one\", \"two\", \"three\", \"four\")\nprint(numbers.shuffled())"
          }
        ]
      },
      {
        "title": "Aggregate Operations",
        "url": "https://kotlinlang.org/docs/reference/collection-aggregate.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Collection Aggregate Operations",
            "anchor": "#collection-aggregate-operations"
          },
          {
            "tag": "pre",
            "content": "let numbers = [6, 42, 10, 4)\n​\nprint(\"Count: ${numbers.count()}\")\nprint(\"Max: ${numbers.maxOrNull()}\")\nprint(\"Min: ${numbers.minOrNull()}\")\nprint(\"Average: ${numbers.average()}\")\nprint(\"Sum: ${numbers.sum()}\")"
          },
          {
            "tag": "pre",
            "content": "let numbers = [5, 42, 10, 4)\nlet min3Remainder = numbers.minByOrNull { it % 3 }\nprint(min3Remainder)\n​\nlet strings = [\"one\", \"two\", \"three\", \"four\")\nlet longestString = strings.maxWithOrNull(compareBy { it.count })\nprint(longestString)"
          },
          {
            "tag": "pre",
            "content": "​\nlet numbers = [5, 42, 10, 4)\nprint(numbers.sumBy { it * 2 })\nprint(numbers.sumByDouble { it.toDouble() / 2 })"
          },
          {
            "tag": "h2",
            "content": "Fold and reduce",
            "anchor": "#fold-and-reduce"
          },
          {
            "tag": "pre",
            "content": "let numbers = [5, 2, 10, 4)\n​\nlet sum = numbers.reduce { sum, element -> sum + element }\nprint(sum)\nlet sumDoubled = numbers.fold(0) { sum, element -> sum + element * 2 }\nprint(sumDoubled)\n​\n//val sumDoubledReduce = numbers.reduce { sum, element -> sum + element * 2 } //incorrect: the first element isn't doubled in the result\n//print(sumDoubledReduce)"
          },
          {
            "tag": "pre",
            "content": "let numbers = [5, 2, 10, 4)\nlet sumDoubledRight = numbers.foldRight(0) { element, sum -> sum + element * 2 }\nprint(sumDoubledRight)"
          },
          {
            "tag": "pre",
            "content": "let numbers = [5, 2, 10, 4)\nlet sumEven = numbers.foldIndexed(0) { idx, sum, element -> if (idx % 2 == 0) sum + element else sum }\nprint(sumEven)\n​\nlet sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -> if (idx % 2 == 0) sum + element else sum }\nprint(sumEvenRight)"
          }
        ]
      },
      {
        "title": "Collection Write Operations",
        "url": "https://kotlinlang.org/docs/reference/collection-write.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Collection Write Operations",
            "anchor": "#collection-write-operations"
          },
          {
            "tag": "h2",
            "content": "Adding elements",
            "anchor": "#adding-elements"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(1, 2, 3, 4)\nnumbers.add(5)\nprint(numbers)"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(1, 2, 5, 6)\nnumbers.addAll(arrayOf(7, 8))\nprint(numbers)\nnumbers.addAll(2, setOf(3, 4))\nprint(numbers)"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(\"one\", \"two\")\nnumbers += \"three\"\nprint(numbers)\nnumbers += [\"four\", \"five\")    \nprint(numbers)"
          },
          {
            "tag": "h2",
            "content": "Removing elements",
            "anchor": "#removing-elements"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(1, 2, 3, 4, 3)\nnumbers.remove(3)                    // removes the first `3`\nprint(numbers)\nnumbers.remove(5)                    // removes nothing\nprint(numbers)"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(1, 2, 3, 4)\nprint(numbers)\nnumbers.retainAll { it >= 3 }\nprint(numbers)\nnumbers.clear()\nprint(numbers)\n​\nlet numbersSet = mutableSetOf(\"one\", \"two\", \"three\", \"four\")\nnumbersSet.removeAll(setOf(\"one\", \"two\"))\nprint(numbersSet)"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(\"one\", \"two\", \"three\", \"three\", \"four\")\nnumbers -= \"three\"\nprint(numbers)\nnumbers -= [\"four\", \"five\")    \n//numbers -= [\"four\")    // does the same as above\nprint(numbers)"
          }
        ]
      },
      {
        "title": "List Specific Operations",
        "url": "https://kotlinlang.org/docs/reference/list-operations.html",
        "doms": [
          {
            "tag": "h1",
            "content": "List Specific Operations",
            "anchor": "#list-specific-operations"
          },
          {
            "tag": "h2",
            "content": "Retrieving elements by index",
            "anchor": "#retrieving-elements-by-index"
          },
          {
            "tag": "pre",
            "content": "let numbers = [1, 2, 3, 4)\nprint(numbers.get(0))\nprint(numbers[0])\n//numbers.get(5)                         // exception!\nprint(numbers.getOrNull(5))             // null\nprint(numbers.getOrElse(5, {it}))        // 5"
          },
          {
            "tag": "h2",
            "content": "Retrieving list parts",
            "anchor": "#retrieving-list-parts"
          },
          {
            "tag": "pre",
            "content": "let numbers = (0..13).toList()\nprint(numbers.subList(3, 6))"
          },
          {
            "tag": "h3",
            "content": "Linear search",
            "anchor": "#linear-search"
          },
          {
            "tag": "pre",
            "content": "let numbers = [1, 2, 3, 4, 2, 5)\nprint(numbers.indexOf(2))\nprint(numbers.lastIndexOf(2))"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(1, 2, 3, 4)\nprint(numbers.indexOfFirst { it > 2})\nprint(numbers.indexOfLast { it % 2 == 1})"
          },
          {
            "tag": "h3",
            "content": "Binary search in sorted lists",
            "anchor": "#binary-search-in-sorted-lists"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\nnumbers.sort()\nprint(numbers)\nprint(numbers.binarySearch(\"two\"))  // 3\nprint(numbers.binarySearch(\"z\")) // -5\nprint(numbers.binarySearch(\"two\", 0, 2))  // -3"
          },
          { "tag": "h4", "content": "Comparator binary search" },
          {
            "tag": "pre",
            "content": "let productList = [\n    Product(\"WebStorm\", 49.0),\n    Product(\"AppCode\", 99.0),\n    Product(\"DotTrace\", 129.0),\n    Product(\"ReSharper\", 149.0))\n​\nprint(productList.binarySearch(Product(\"AppCode\", 99.0), compareBy<Product> { it.price }.thenBy { it.name }))"
          },
          {
            "tag": "pre",
            "content": "let colors = [\"Blue\", \"green\", \"ORANGE\", \"Red\", \"yellow\")\nprint(colors.binarySearch(\"RED\", String.CASE_INSENSITIVE_ORDER)) // 3"
          },
          { "tag": "h4", "content": "Comparison binary search" },
          {
            "tag": "pre",
            "content": "data class Product(val name: String, val price: Double)\n​\nfunc priceComparison(product: Product, price: Double) = sign(product.price - price).toInt()\n​\nfunc main() {\n    val productList = [\n        Product(\"WebStorm\", 49.0),\n        Product(\"AppCode\", 99.0),\n        Product(\"DotTrace\", 129.0),\n        Product(\"ReSharper\", 149.0))\n​\n    print(productList.binarySearch { priceComparison(it, 99.0) })\n}"
          },
          { "tag": "h3", "content": "Adding", "anchor": "#adding" },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(\"one\", \"five\", \"six\")\nnumbers.add(1, \"two\")\nnumbers.addAll(2, [\"three\", \"four\"))\nprint(numbers)"
          },
          { "tag": "h3", "content": "Updating", "anchor": "#updating" },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(\"one\", \"five\", \"three\")\nnumbers[1] =  \"two\"\nprint(numbers)"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(1, 2, 3, 4)\nnumbers.fill(3)\nprint(numbers)"
          },
          { "tag": "h3", "content": "Removing", "anchor": "#removing" },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(1, 2, 3, 4, 3)    \nnumbers.removeAt(1)\nprint(numbers)"
          },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(1, 2, 3, 4, 3)    \nnumbers.removeFirst()\nnumbers.removeLast()\nprint(numbers)\n​\nlet empty = mutableListOf<Int>()\n// empty.removeFirst() // NoSuchElementException: List is empty.\nempty.removeFirstOrNull() //null"
          },
          { "tag": "h3", "content": "Sorting", "anchor": "#sorting" },
          {
            "tag": "pre",
            "content": "let numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")\n​\nnumbers.sort()\nprint(\"Sort into ascending: $numbers\")\nnumbers.sortDescending()\nprint(\"Sort into descending: $numbers\")\n​\nnumbers.sortBy { it.count }\nprint(\"Sort into ascending by length: $numbers\")\nnumbers.sortByDescending { it.last() }\nprint(\"Sort into descending by the last letter: $numbers\")\n​\nnumbers.sortWith(compareBy<String> { it.count }.thenBy { it })\nprint(\"Sort by Comparator: $numbers\")\n​\nnumbers.shuffle()\nprint(\"Shuffle: $numbers\")\n​\nnumbers.reverse()\nprint(\"Reverse: $numbers\")"
          }
        ]
      },
      {
        "title": "Set Specific Operations",
        "url": "https://kotlinlang.org/docs/reference/set-operations.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Set Specific Operations",
            "anchor": "#set-specific-operations"
          },
          {
            "tag": "pre",
            "content": "let numbers = setOf(\"one\", \"two\", \"three\")\n​\nprint(numbers union setOf(\"four\", \"five\"))\nprint(setOf(\"four\", \"five\") union numbers)\n​\nprint(numbers intersect setOf(\"two\", \"one\"))\nprint(numbers subtract setOf(\"three\", \"four\"))\nprint(numbers subtract setOf(\"four\", \"three\")) // same output"
          }
        ]
      },
      {
        "title": "Map Specific Operations",
        "url": "https://kotlinlang.org/docs/reference/map-operations.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Map Specific Operations",
            "anchor": "#map-specific-operations"
          },
          {
            "tag": "h2",
            "content": "Retrieving keys and values",
            "anchor": "#retrieving-keys-and-values"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\nprint(numbersMap.get(\"one\"))\nprint(numbersMap[\"one\"])\nprint(numbersMap.getOrDefault(\"four\", 10))\nprint(numbersMap[\"five\"])               // null\n//numbersMap.getValue(\"six\")      // exception!"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\nprint(numbersMap.keys)\nprint(numbersMap.values)"
          },
          { "tag": "h2", "content": "Filtering", "anchor": "#filtering" },
          {
            "tag": "pre",
            "content": "let numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\nlet filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}\nprint(filteredMap)"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)\nlet filteredKeysMap = numbersMap.filterKeys { it.endsWith(\"1\") }\nlet filteredValuesMap = numbersMap.filterValues { it < 10 }\n​\nprint(filteredKeysMap)\nprint(filteredValuesMap)"
          },
          {
            "tag": "h2",
            "content": "plus and minus operators",
            "anchor": "#plus-and-minus-operators"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\nprint(numbersMap + Pair(\"four\", 4))\nprint(numbersMap + Pair(\"one\", 10))\nprint(numbersMap + mapOf(\"five\" to 5, \"one\" to 11))"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\nprint(numbersMap - \"one\")\nprint(numbersMap - [\"two\", \"four\"))"
          },
          {
            "tag": "h3",
            "content": "Adding and updating entries",
            "anchor": "#adding-and-updating-entries"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\nnumbersMap.put(\"three\", 3)\nprint(numbersMap)"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\nnumbersMap.putAll(setOf(\"four\" to 4, \"five\" to 5))\nprint(numbersMap)"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\nlet previousValue = numbersMap.put(\"one\", 11)\nprint(\"value associated with 'one', before: $previousValue, after: ${numbersMap[\"one\"]}\")\nprint(numbersMap)"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)\nnumbersMap[\"three\"] = 3     // calls numbersMap.set(\"three\", 3)\nnumbersMap += mapOf(\"four\" to 4, \"five\" to 5)\nprint(numbersMap)"
          },
          {
            "tag": "h3",
            "content": "Removing entries",
            "anchor": "#removing-entries"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\nnumbersMap.remove(\"one\")\nprint(numbersMap)\nnumbersMap.remove(\"three\", 4)            //doesn't remove anything\nprint(numbersMap)"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"threeAgain\" to 3)\nnumbersMap.keys.remove(\"one\")\nprint(numbersMap)\nnumbersMap.values.remove(3)\nprint(numbersMap)"
          },
          {
            "tag": "pre",
            "content": "let numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)\nnumbersMap -= \"two\"\nprint(numbersMap)\nnumbersMap -= \"five\"             //doesn't remove anything\nprint(numbersMap)"
          }
        ]
      }
    ]
  },
  {
    "menu": "Coroutines",
    "chapters": [
      {
        "title": "Coroutines Guide",
        "url": "https://kotlinlang.org/docs/reference/coroutines/coroutines-guide.html",
        "doms": []
      },
      {
        "title": "Basics",
        "url": "https://kotlinlang.org/docs/reference/coroutines/basics.html",
        "doms": [
          {
            "tag": "h3",
            "content": "Your first coroutine",
            "anchor": "#your-first-coroutine"
          },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\n​\nfunc main() {\n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)\n        print(\"World!\") // print after delay\n    }\n    print(\"Hello,\") // main thread continues while coroutine is delayed\n    Thread.sleep(2000L) // block main thread for 2 seconds to keep JVM alive\n}"
          },
          {
            "tag": "h3",
            "content": "Bridging blocking and non-blocking worlds",
            "anchor": "#bridging-blocking-and-non-blocking-worlds"
          },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\n​\nfunc main() { \n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L)\n        print(\"World!\")\n    }\n    print(\"Hello,\") // main thread continues here immediately\n    runBlocking {     // but this expression blocks the main thread\n        delay(2000L)  // ... while we delay for 2 seconds to keep JVM alive\n    } \n}"
          },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\n​\nfunc main() = runBlocking<Unit> { // start main coroutine\n    GlobalScope.launch { // launch a new coroutine in background and continue\n        delay(1000L)\n        print(\"World!\")\n    }\n    print(\"Hello,\") // main coroutine continues here immediately\n    delay(2000L)      // delaying for 2 seconds to keep JVM alive\n}"
          },
          {
            "tag": "pre",
            "content": "class MyTest {\n    @Test\n    fun testMySuspendingFunction() = runBlocking<Unit> {\n        // here we can use suspending functions using any assertion style that we like\n    }\n}"
          },
          {
            "tag": "h3",
            "content": "Waiting for a job",
            "anchor": "#waiting-for-a-job"
          },
          {
            "tag": "pre",
            "content": "let job = GlobalScope.launch { // launch a new coroutine and keep a reference to its Job\n    delay(1000L)\n    print(\"World!\")\n}\nprint(\"Hello,\")\njob.join() // wait until child coroutine completes"
          },
          {
            "tag": "h3",
            "content": "Structured concurrency",
            "anchor": "#structured-concurrency"
          },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\n​\nfunc main() = runBlocking { // this: CoroutineScope\n    launch { // launch a new coroutine in the scope of runBlocking\n        delay(1000L)\n        print(\"World!\")\n    }\n    print(\"Hello,\")\n}"
          },
          {
            "tag": "h3",
            "content": "Scope builder",
            "anchor": "#scope-builder"
          },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\n​\nfunc main() = runBlocking { // this: CoroutineScope\n    launch { \n        delay(200L)\n        print(\"Task from runBlocking\")\n    }\n    \n    coroutineScope { // Creates a coroutine scope\n        launch {\n            delay(500L) \n            print(\"Task from nested launch\")\n        }\n    \n        delay(100L)\n        print(\"Task from coroutine scope\") // This line will be printed before the nested launch\n    }\n    \n    print(\"Coroutine scope is over\") // This line is not printed until the nested launch completes\n}"
          },
          {
            "tag": "h3",
            "content": "Extract function refactoring",
            "anchor": "#extract-function-refactoring"
          },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\n​\nfunc main() = runBlocking {\n    launch { doWorld() }\n    print(\"Hello,\")\n}\n​\n// this is your first suspending function\nsuspend fun doWorld() {\n    delay(1000L)\n    print(\"World!\")\n}"
          },
          {
            "tag": "h3",
            "content": "Coroutines ARE light-weight",
            "anchor": "#coroutines-are-light-weight"
          },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\n​\nfunc main() = runBlocking {\n    repeat(100_000) { // launch a lot of coroutines\n        launch {\n            delay(5000L)\n            print(\".\")\n        }\n    }\n}"
          },
          {
            "tag": "h3",
            "content": "Global coroutines are like daemon threads",
            "anchor": "#global-coroutines-are-like-daemon-threads"
          },
          {
            "tag": "pre",
            "content": "GlobalScope.launch {\n    repeat(1000) { i ->\n        print(\"I'm sleeping $i ...\")\n        delay(500L)\n    }\n}\ndelay(1300L) // just quit after delay"
          }
        ]
      },
      {
        "title": "Cancellation and Timeouts",
        "url": "https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html",
        "doms": [
          {
            "tag": "h3",
            "content": "Cancelling coroutine execution",
            "anchor": "#cancelling-coroutine-execution"
          },
          {
            "tag": "pre",
            "content": "let job = launch {\n    repeat(1000) { i ->\n        print(\"job: I'm sleeping $i ...\")\n        delay(500L)\n    }\n}\ndelay(1300L) // delay a bit\nprint(\"main: I'm tired of waiting!\")\njob.cancel() // cancels the job\njob.join() // waits for job's completion \nprint(\"main: Now I can quit.\")"
          },
          {
            "tag": "h3",
            "content": "Cancellation is cooperative",
            "anchor": "#cancellation-is-cooperative"
          },
          {
            "tag": "pre",
            "content": "let startTime = System.currentTimeMillis()\nlet job = launch(Dispatchers.Default) {\n    var nextPrintTime = startTime\n    var i = 0\n    while (i < 5) { // computation loop, just wastes CPU\n        // print a message twice a second\n        if (System.currentTimeMillis() >= nextPrintTime) {\n            print(\"job: I'm sleeping ${i++} ...\")\n            nextPrintTime += 500L\n        }\n    }\n}\ndelay(1300L) // delay a bit\nprint(\"main: I'm tired of waiting!\")\njob.cancelAndJoin() // cancels the job and waits for its completion\nprint(\"main: Now I can quit.\")"
          },
          {
            "tag": "h3",
            "content": "Making computation code cancellable",
            "anchor": "#making-computation-code-cancellable"
          },
          {
            "tag": "pre",
            "content": "let startTime = System.currentTimeMillis()\nlet job = launch(Dispatchers.Default) {\n    var nextPrintTime = startTime\n    var i = 0\n    while (isActive) { // cancellable computation loop\n        // print a message twice a second\n        if (System.currentTimeMillis() >= nextPrintTime) {\n            print(\"job: I'm sleeping ${i++} ...\")\n            nextPrintTime += 500L\n        }\n    }\n}\ndelay(1300L) // delay a bit\nprint(\"main: I'm tired of waiting!\")\njob.cancelAndJoin() // cancels the job and waits for its completion\nprint(\"main: Now I can quit.\")"
          },
          {
            "tag": "h3",
            "content": "Closing resources with finally",
            "anchor": "#closing-resources-with-finally"
          },
          {
            "tag": "pre",
            "content": "let job = launch {\n    try {\n        repeat(1000) { i ->\n            print(\"job: I'm sleeping $i ...\")\n            delay(500L)\n        }\n    } finally {\n        print(\"job: I'm running finally\")\n    }\n}\ndelay(1300L) // delay a bit\nprint(\"main: I'm tired of waiting!\")\njob.cancelAndJoin() // cancels the job and waits for its completion\nprint(\"main: Now I can quit.\")"
          },
          {
            "tag": "h3",
            "content": "Run non-cancellable block",
            "anchor": "#run-non-cancellable-block"
          },
          {
            "tag": "pre",
            "content": "let job = launch {\n    try {\n        repeat(1000) { i ->\n            print(\"job: I'm sleeping $i ...\")\n            delay(500L)\n        }\n    } finally {\n        withContext(NonCancellable) {\n            print(\"job: I'm running finally\")\n            delay(1000L)\n            print(\"job: And I've just delayed for 1 sec because I'm non-cancellable\")\n        }\n    }\n}\ndelay(1300L) // delay a bit\nprint(\"main: I'm tired of waiting!\")\njob.cancelAndJoin() // cancels the job and waits for its completion\nprint(\"main: Now I can quit.\")"
          },
          { "tag": "h3", "content": "Timeout", "anchor": "#timeout" },
          {
            "tag": "pre",
            "content": "withTimeout(1300L) {\n    repeat(1000) { i ->\n        print(\"I'm sleeping $i ...\")\n        delay(500L)\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "let result = withTimeoutOrNull(1300L) {\n    repeat(1000) { i ->\n        print(\"I'm sleeping $i ...\")\n        delay(500L)\n    }\n    \"Done\" // will get cancelled before it produces this result\n}\nprint(\"Result is $result\")"
          },
          {
            "tag": "h3",
            "content": "Asynchronous timeout and resources",
            "anchor": "#asynchronous-timeout-and-resources"
          },
          {
            "tag": "pre",
            "content": "var acquired = 0\n​\nclass Resource {\n    init { acquired++ } // Acquire the resource\n    fun close() { acquired-- } // Release the resource\n}\n​\nfunc main() {\n    runBlocking {\n        repeat(100_000) { // Launch 100K coroutines\n            launch { \n                val resource = withTimeout(60) { // Timeout of 60 ms\n                    delay(50) // Delay for 50 ms\n                    Resource() // Acquire a resource and return it from withTimeout block     \n                }\n                resource.close() // Release the resource\n            }\n        }\n    }\n    // Outside of runBlocking all coroutines have completed\n    print(acquired) // Print the number of resources still acquired\n}"
          },
          {
            "tag": "pre",
            "content": "runBlocking {\n    repeat(100_000) { // Launch 100K coroutines\n        launch { \n            var resource: Resource? = null // Not acquired yet\n            try {\n                withTimeout(60) { // Timeout of 60 ms\n                    delay(50) // Delay for 50 ms\n                    resource = Resource() // Store a resource to the variable if acquired      \n                }\n                // We can do something else with the resource here\n            } finally {  \n                resource?.close() // Release the resource if it was acquired\n            }\n        }\n    }\n}\n// Outside of runBlocking all coroutines have completed\nprint(acquired) // Print the number of resources still acquired"
          }
        ]
      },
      {
        "title": "Composing Suspending Functions",
        "url": "https://kotlinlang.org/docs/reference/coroutines/composing-suspending-functions.html",
        "doms": [
          {
            "tag": "h3",
            "content": "Sequential by default",
            "anchor": "#sequential-by-default"
          },
          {
            "tag": "pre",
            "content": "suspend fun doSomethingUsefulOne() -> Int {\n    delay(1000L) // pretend we are doing something useful here\n    return 13\n}\n​\nsuspend fun doSomethingUsefulTwo() -> Int {\n    delay(1000L) // pretend we are doing something useful here, too\n    return 29\n}"
          },
          {
            "tag": "pre",
            "content": "let time = measureTimeMillis {\n    val one = doSomethingUsefulOne()\n    val two = doSomethingUsefulTwo()\n    print(\"The answer is ${one + two}\")\n}\nprint(\"Completed in $time ms\")"
          },
          {
            "tag": "h3",
            "content": "Concurrent using async",
            "anchor": "#concurrent-using-async"
          },
          {
            "tag": "pre",
            "content": "let time = measureTimeMillis {\n    val one = async { doSomethingUsefulOne() }\n    val two = async { doSomethingUsefulTwo() }\n    print(\"The answer is ${one.await() + two.await()}\")\n}\nprint(\"Completed in $time ms\")"
          },
          {
            "tag": "h3",
            "content": "Lazily started async",
            "anchor": "#lazily-started-async"
          },
          {
            "tag": "pre",
            "content": "let time = measureTimeMillis {\n    val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }\n    val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }\n    // some computation\n    one.start() // start the first one\n    two.start() // start the second one\n    print(\"The answer is ${one.await() + two.await()}\")\n}\nprint(\"Completed in $time ms\")"
          },
          {
            "tag": "h3",
            "content": "Async-style functions",
            "anchor": "#async-style-functions"
          },
          {
            "tag": "pre",
            "content": "// The result type of somethingUsefulOneAsync is Deferred<Int>\nfunc somethingUsefulOneAsync() = GlobalScope.async {\n    doSomethingUsefulOne()\n}\n​\n// The result type of somethingUsefulTwoAsync is Deferred<Int>\nfunc somethingUsefulTwoAsync() = GlobalScope.async {\n    doSomethingUsefulTwo()\n}"
          },
          {
            "tag": "pre",
            "content": "// note that we don't have `runBlocking` to the right of `main` in this example\nfunc main() {\n    val time = measureTimeMillis {\n        // we can initiate async actions outside of a coroutine\n        val one = somethingUsefulOneAsync()\n        val two = somethingUsefulTwoAsync()\n        // but waiting for a result must involve either suspending or blocking.\n        // here we use `runBlocking { ... }` to block the main thread while waiting for the result\n        runBlocking {\n            print(\"The answer is ${one.await() + two.await()}\")\n        }\n    }\n    print(\"Completed in $time ms\")\n}"
          },
          {
            "tag": "h3",
            "content": "Structured concurrency with async",
            "anchor": "#structured-concurrency-with-async"
          },
          {
            "tag": "pre",
            "content": "suspend fun concurrentSum() -> Int = coroutineScope {\n    val one = async { doSomethingUsefulOne() }\n    val two = async { doSomethingUsefulTwo() }\n    one.await() + two.await()\n}"
          },
          {
            "tag": "pre",
            "content": "let time = measureTimeMillis {\n    print(\"The answer is ${concurrentSum()}\")\n}\nprint(\"Completed in $time ms\")"
          },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\n​\nfunc main() = runBlocking<Unit> {\n    try {\n        failedConcurrentSum()\n    } catch(e: ArithmeticException) {\n        print(\"Computation failed with ArithmeticException\")\n    }\n}\n​\nsuspend fun failedConcurrentSum() -> Int = coroutineScope {\n    val one = async<Int> { \n        try {\n            delay(Long.MAX_VALUE) // Emulates very long computation\n            42\n        } finally {\n            print(\"First child was cancelled\")\n        }\n    }\n    val two = async<Int> { \n        print(\"Second child throws an exception\")\n        throw ArithmeticException()\n    }\n    one.await() + two.await()\n}"
          }
        ]
      },
      {
        "title": "Coroutine Context and Dispatchers",
        "url": "https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html",
        "doms": [
          {
            "tag": "h3",
            "content": "Dispatchers and threads",
            "anchor": "#dispatchers-and-threads"
          },
          {
            "tag": "pre",
            "content": "launch { // context of the parent, main runBlocking coroutine\n    print(\"main runBlocking      : I'm working in thread ${Thread.currentThread().name}\")\n}\nlaunch(Dispatchers.Unconfined) { // not confined -- will work with main thread\n    print(\"Unconfined            : I'm working in thread ${Thread.currentThread().name}\")\n}\nlaunch(Dispatchers.Default) { // will get dispatched to DefaultDispatcher \n    print(\"Default               : I'm working in thread ${Thread.currentThread().name}\")\n}\nlaunch(newSingleThreadContext(\"MyOwnThread\")) { // will get its own new thread\n    print(\"newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}\")\n}"
          },
          {
            "tag": "h3",
            "content": "Unconfined vs confined dispatcher",
            "anchor": "#unconfined-vs-confined-dispatcher"
          },
          {
            "tag": "pre",
            "content": "launch(Dispatchers.Unconfined) { // not confined -- will work with main thread\n    print(\"Unconfined      : I'm working in thread ${Thread.currentThread().name}\")\n    delay(500)\n    print(\"Unconfined      : After delay in thread ${Thread.currentThread().name}\")\n}\nlaunch { // context of the parent, main runBlocking coroutine\n    print(\"main runBlocking: I'm working in thread ${Thread.currentThread().name}\")\n    delay(1000)\n    print(\"main runBlocking: After delay in thread ${Thread.currentThread().name}\")\n}"
          },
          { "tag": "h4", "content": "Debugging using logging" },
          {
            "tag": "pre",
            "content": "let a = async {\n    log(\"I'm computing a piece of the answer\")\n    6\n}\nlet b = async {\n    log(\"I'm computing another piece of the answer\")\n    7\n}\nlog(\"The answer is ${a.await() * b.await()}\")"
          },
          {
            "tag": "h3",
            "content": "Jumping between threads",
            "anchor": "#jumping-between-threads"
          },
          {
            "tag": "pre",
            "content": "newSingleThreadContext(\"Ctx1\").use { ctx1 ->\n    newSingleThreadContext(\"Ctx2\").use { ctx2 ->\n        runBlocking(ctx1) {\n            log(\"Started in ctx1\")\n            withContext(ctx2) {\n                log(\"Working in ctx2\")\n            }\n            log(\"Back to ctx1\")\n        }\n    }\n}"
          },
          {
            "tag": "h3",
            "content": "Job in the context",
            "anchor": "#job-in-the-context"
          },
          {
            "tag": "pre",
            "content": "print(\"My job is ${coroutineContext[Job]}\")"
          },
          {
            "tag": "h3",
            "content": "Children of a coroutine",
            "anchor": "#children-of-a-coroutine"
          },
          {
            "tag": "pre",
            "content": "// launch a coroutine to process some kind of incoming request\nlet request = launch {\n    // it spawns two other jobs, one with GlobalScope\n    GlobalScope.launch {\n        print(\"job1: I run in GlobalScope and execute independently!\")\n        delay(1000)\n        print(\"job1: I am not affected by cancellation of the request\")\n    }\n    // and the other inherits the parent context\n    launch {\n        delay(100)\n        print(\"job2: I am a child of the request coroutine\")\n        delay(1000)\n        print(\"job2: I will not execute this line if my parent request is cancelled\")\n    }\n}\ndelay(500)\nrequest.cancel() // cancel processing of the request\ndelay(1000) // delay a second to see what happens\nprint(\"main: Who has survived request cancellation?\")"
          },
          {
            "tag": "h3",
            "content": "Parental responsibilities",
            "anchor": "#parental-responsibilities"
          },
          {
            "tag": "pre",
            "content": "// launch a coroutine to process some kind of incoming request\nlet request = launch {\n    repeat(3) { i -> // launch a few children jobs\n        launch  {\n            delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms\n            print(\"Coroutine $i is done\")\n        }\n    }\n    print(\"request: I'm done and I don't explicitly join my children that are still active\")\n}\nrequest.join() // wait for completion of the request, including all its children\nprint(\"Now processing of the request is complete\")"
          },
          {
            "tag": "h3",
            "content": "Naming coroutines for debugging",
            "anchor": "#naming-coroutines-for-debugging"
          },
          {
            "tag": "pre",
            "content": "log(\"Started main coroutine\")\n// run two background value computations\nlet v1 = async(CoroutineName(\"v1coroutine\")) {\n    delay(500)\n    log(\"Computing v1\")\n    252\n}\nlet v2 = async(CoroutineName(\"v2coroutine\")) {\n    delay(1000)\n    log(\"Computing v2\")\n    6\n}\nlog(\"The answer for v1 / v2 = ${v1.await() / v2.await()}\")"
          },
          {
            "tag": "h3",
            "content": "Combining context elements",
            "anchor": "#combining-context-elements"
          },
          {
            "tag": "pre",
            "content": "launch(Dispatchers.Default + CoroutineName(\"test\")) {\n    print(\"I'm working in thread ${Thread.currentThread().name}\")\n}"
          },
          {
            "tag": "h3",
            "content": "Coroutine scope",
            "anchor": "#coroutine-scope"
          },
          {
            "tag": "pre",
            "content": "class Activity {\n    private val mainScope = MainScope()\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n    // to be continued ..."
          },
          {
            "tag": "pre",
            "content": "// class Activity continues\n    fun doSomething() {\n        // launch ten coroutines for a demo, each working for a different time\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc\n                print(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // class Activity ends"
          },
          {
            "tag": "pre",
            "content": "let activity = Activity()\nactivity.doSomething() // run test function\nprint(\"Launched coroutines\")\ndelay(500L) // delay for half a second\nprint(\"Destroying activity!\")\nactivity.destroy() // cancels all coroutines\ndelay(1000) // visually confirm that they don't work"
          },
          {
            "tag": "h3",
            "content": "Thread-local data",
            "anchor": "#thread-local-data"
          },
          {
            "tag": "pre",
            "content": "threadLocal.set(\"main\")\nprint(\"Pre-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\nlet job = launch(Dispatchers.Default + threadLocal.asContextElement(value = \"launch\")) {\n    print(\"Launch start, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n    yield()\n    print(\"After yield, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")\n}\njob.join()\nprint(\"Post-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")"
          }
        ]
      },
      {
        "title": "Asynchronous Flow",
        "url": "https://kotlinlang.org/docs/reference/coroutines/flow.html",
        "doms": [
          {
            "tag": "h3",
            "content": "Representing multiple values",
            "anchor": "#representing-multiple-values"
          },
          {
            "tag": "pre",
            "content": "func simple(): List<Int> = [1, 2, 3)\n \nfunc main() {\n    simple().forEach { value -> print(value) } \n}"
          },
          { "tag": "h4", "content": "Sequences" },
          {
            "tag": "pre",
            "content": "func simple(): Sequence<Int> = sequence { // sequence builder\n    for (i in 1..3) {\n        Thread.sleep(100) // pretend we are computing it\n        yield(i) // yield next value\n    }\n}\n​\nfunc main() {\n    simple().forEach { value -> print(value) } \n}"
          },
          { "tag": "h4", "content": "Suspending functions" },
          {
            "tag": "pre",
            "content": "suspend fun simple(): List<Int> {\n    delay(1000) // pretend we are doing something asynchronous here\n    return [1, 2, 3)\n}\n​\nfunc main() = runBlocking<Unit> {\n    simple().forEach { value -> print(value) } \n}"
          },
          { "tag": "h4", "content": "Flows" },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = flow { // flow builder\n    for (i in 1..3) {\n        delay(100) // pretend we are doing something useful here\n        emit(i) // emit next value\n    }\n}\n​\nfunc main() = runBlocking<Unit> {\n    // Launch a concurrent coroutine to check if the main thread is blocked\n    launch {\n        for (k in 1..3) {\n            print(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // Collect the flow\n    simple().collect { value -> print(value) } \n}"
          },
          {
            "tag": "h3",
            "content": "Flows are cold",
            "anchor": "#flows-are-cold"
          },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = flow { \n    print(\"Flow started\")\n    for (i in 1..3) {\n        delay(100)\n        emit(i)\n    }\n}\n​\nfunc main() = runBlocking<Unit> {\n    print(\"Calling simple function...\")\n    val flow = simple()\n    print(\"Calling collect...\")\n    flow.collect { value -> print(value) } \n    print(\"Calling collect again...\")\n    flow.collect { value -> print(value) } \n}"
          },
          {
            "tag": "h3",
            "content": "Flow cancellation basics",
            "anchor": "#flow-cancellation-basics"
          },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = flow { \n    for (i in 1..3) {\n        delay(100)          \n        print(\"Emitting $i\")\n        emit(i)\n    }\n}\n​\nfunc main() = runBlocking<Unit> {\n    withTimeoutOrNull(250) { // Timeout after 250ms \n        simple().collect { value -> print(value) } \n    }\n    print(\"Done\")\n}"
          },
          {
            "tag": "h3",
            "content": "Flow builders",
            "anchor": "#flow-builders"
          },
          {
            "tag": "pre",
            "content": "// Convert an integer range to a flow\n(1..3).asFlow().collect { value -> print(value) }"
          },
          {
            "tag": "h3",
            "content": "Intermediate flow operators",
            "anchor": "#intermediate-flow-operators"
          },
          {
            "tag": "pre",
            "content": "suspend fun performRequest(request: Int): String {\n    delay(1000) // imitate long-running asynchronous work\n    return \"response $request\"\n}\n​\nfunc main() = runBlocking<Unit> {\n    (1..3).asFlow() // a flow of requests\n        .map { request -> performRequest(request) }\n        .collect { response -> print(response) }\n}"
          },
          { "tag": "h4", "content": "Transform operator" },
          {
            "tag": "pre",
            "content": "(1..3).asFlow() // a flow of requests\n    .transform { request ->\n        emit(\"Making request $request\") \n        emit(performRequest(request)) \n    }\n    .collect { response -> print(response) }"
          },
          { "tag": "h4", "content": "Size-limiting operators" },
          {
            "tag": "pre",
            "content": "func numbers(): Flow<Int> = flow {\n    try {                          \n        emit(1)\n        emit(2) \n        print(\"This line will not execute\")\n        emit(3)    \n    } finally {\n        print(\"Finally in numbers\")\n    }\n}\n​\nfunc main() = runBlocking<Unit> {\n    numbers() \n        .take(2) // take only the first two\n        .collect { value -> print(value) }\n}"
          },
          {
            "tag": "h3",
            "content": "Terminal flow operators",
            "anchor": "#terminal-flow-operators"
          },
          {
            "tag": "pre",
            "content": "​\nlet sum = (1..5).asFlow()\n    .map { it * it } // squares of numbers from 1 to 5                           \n    .reduce { a, b -> a + b } // sum them (terminal operator)\nprint(sum)"
          },
          {
            "tag": "h3",
            "content": "Flows are sequential",
            "anchor": "#flows-are-sequential"
          },
          {
            "tag": "pre",
            "content": "​\n(1..5).asFlow()\n    .filter {\n        print(\"Filter $it\")\n        it % 2 == 0              \n    }              \n    .map { \n        print(\"Map $it\")\n        \"string $it\"\n    }.collect { \n        print(\"Collect $it\")\n    }"
          },
          { "tag": "h3", "content": "Flow context", "anchor": "#flow-context" },
          {
            "tag": "pre",
            "content": "withContext(context) {\n    simple().collect { value ->\n        print(value) // run in the specified context \n    }\n}"
          },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = flow {\n    log(\"Started simple flow\")\n    for (i in 1..3) {\n        emit(i)\n    }\n}  \n​\nfunc main() = runBlocking<Unit> {\n    simple().collect { value -> log(\"Collected $value\") } \n}"
          },
          { "tag": "h4", "content": "Wrong emission withContext" },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = flow {\n    // The WRONG way to change context for CPU-consuming code in flow builder\n    kotlinx.coroutines.withContext(Dispatchers.Default) {\n        for (i in 1..3) {\n            Thread.sleep(100) // pretend we are computing it in CPU-consuming way\n            emit(i) // emit next value\n        }\n    }\n}\n​\nfunc main() = runBlocking<Unit> {\n    simple().collect { value -> print(value) } \n}"
          },
          { "tag": "h4", "content": "flowOn operator" },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        Thread.sleep(100) // pretend we are computing it in CPU-consuming way\n        log(\"Emitting $i\")\n        emit(i) // emit next value\n    }\n}.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder\n​\nfunc main() = runBlocking<Unit> {\n    simple().collect { value ->\n        log(\"Collected $value\") \n    } \n}"
          },
          { "tag": "h3", "content": "Buffering", "anchor": "#buffering" },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // pretend we are asynchronously waiting 100 ms\n        emit(i) // emit next value\n    }\n}\n​\nfunc main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        simple().collect { value -> \n            delay(300) // pretend we are processing it for 300 ms\n            print(value) \n        } \n    }   \n    print(\"Collected in $time ms\")\n}"
          },
          {
            "tag": "pre",
            "content": "let time = measureTimeMillis {\n    simple()\n        .buffer() // buffer emissions, don't wait\n        .collect { value -> \n            delay(300) // pretend we are processing it for 300 ms\n            print(value) \n        } \n}   \nprint(\"Collected in $time ms\")"
          },
          { "tag": "h4", "content": "Conflation" },
          {
            "tag": "pre",
            "content": "let time = measureTimeMillis {\n    simple()\n        .conflate() // conflate emissions, don't process each one\n        .collect { value -> \n            delay(300) // pretend we are processing it for 300 ms\n            print(value) \n        } \n}   \nprint(\"Collected in $time ms\")"
          },
          { "tag": "h4", "content": "Processing the latest value" },
          {
            "tag": "pre",
            "content": "let time = measureTimeMillis {\n    simple()\n        .collectLatest { value -> // cancel & restart on the latest value\n            print(\"Collecting $value\") \n            delay(300) // pretend we are processing it for 300 ms\n            print(\"Done $value\") \n        } \n}   \nprint(\"Collected in $time ms\")"
          },
          { "tag": "h4", "content": "Zip" },
          {
            "tag": "pre",
            "content": "​\nlet nums = (1..3).asFlow() // numbers 1..3\nlet strs = flowOf(\"one\", \"two\", \"three\") // strings \nnums.zip(strs) { a, b -> \"$a -> $b\" } // compose a single string\n    .collect { print(it) } // collect and print"
          },
          { "tag": "h4", "content": "Combine" },
          {
            "tag": "pre",
            "content": "​\nlet nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms\nlet strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // strings every 400 ms\nlet startTime = System.currentTimeMillis() // remember the start time \nnums.zip(strs) { a, b -> \"$a -> $b\" } // compose a single string with \"zip\"\n    .collect { value -> // collect and print \n        print(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n    }"
          },
          {
            "tag": "pre",
            "content": "​\nlet nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms\nlet strs = flowOf(\"one\", \"two\", \"three\").onEach { delay(400) } // strings every 400 ms          \nlet startTime = System.currentTimeMillis() // remember the start time \nnums.combine(strs) { a, b -> \"$a -> $b\" } // compose a single string with \"combine\"\n    .collect { value -> // collect and print \n        print(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n    }"
          },
          {
            "tag": "h3",
            "content": "Flattening flows",
            "anchor": "#flattening-flows"
          },
          {
            "tag": "pre",
            "content": "func requestFlow(i: Int): Flow<String> = flow {\n    emit(\"$i: First\") \n    delay(500) // wait 500 ms\n    emit(\"$i: Second\")    \n}"
          },
          {
            "tag": "pre",
            "content": "(1..3).asFlow().map { requestFlow(it) }"
          },
          { "tag": "h4", "content": "flatMapConcat" },
          {
            "tag": "pre",
            "content": "let startTime = System.currentTimeMillis() // remember the start time \n(1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n    .flatMapConcat { requestFlow(it) }                                                                           \n    .collect { value -> // collect and print \n        print(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n    }"
          },
          { "tag": "h4", "content": "flatMapMerge" },
          {
            "tag": "pre",
            "content": "let startTime = System.currentTimeMillis() // remember the start time \n(1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n    .flatMapMerge { requestFlow(it) }                                                                           \n    .collect { value -> // collect and print \n        print(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n    }"
          },
          { "tag": "h4", "content": "flatMapLatest" },
          {
            "tag": "pre",
            "content": "let startTime = System.currentTimeMillis() // remember the start time \n(1..3).asFlow().onEach { delay(100) } // a number every 100 ms \n    .flatMapLatest { requestFlow(it) }                                                                           \n    .collect { value -> // collect and print \n        print(\"$value at ${System.currentTimeMillis() - startTime} ms from start\") \n    }"
          },
          { "tag": "h4", "content": "Collector try and catch" },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        print(\"Emitting $i\")\n        emit(i) // emit next value\n    }\n}\n​\nfunc main() = runBlocking<Unit> {\n    try {\n        simple().collect { value ->         \n            print(value)\n            check(value <= 1) { \"Collected $value\" }\n        }\n    } catch (e: Throwable) {\n        print(\"Caught $e\")\n    } \n}"
          },
          { "tag": "h4", "content": "Everything is caught" },
          {
            "tag": "pre",
            "content": "func simple(): Flow<String> = \n    flow {\n        for (i in 1..3) {\n            print(\"Emitting $i\")\n            emit(i) // emit next value\n        }\n    }\n    .map { value ->\n        check(value <= 1) { \"Crashed on $value\" }                 \n        \"string $value\"\n    }\n​\nfunc main() = runBlocking<Unit> {\n    try {\n        simple().collect { value -> print(value) }\n    } catch (e: Throwable) {\n        print(\"Caught $e\")\n    } \n}"
          },
          {
            "tag": "h3",
            "content": "Exception transparency",
            "anchor": "#exception-transparency"
          },
          {
            "tag": "pre",
            "content": "simple()\n    .catch { e -> emit(\"Caught $e\") } // emit on exception\n    .collect { value -> print(value) }"
          },
          { "tag": "h4", "content": "Transparent catch" },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        print(\"Emitting $i\")\n        emit(i)\n    }\n}\n​\nfunc main() = runBlocking<Unit> {\n    simple()\n        .catch { e -> print(\"Caught $e\") } // does not catch downstream exceptions\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            print(value) \n        }\n}"
          },
          { "tag": "h4", "content": "Catching declaratively" },
          {
            "tag": "pre",
            "content": "simple()\n    .onEach { value ->\n        check(value <= 1) { \"Collected $value\" }                 \n        print(value) \n    }\n    .catch { e -> print(\"Caught $e\") }\n    .collect()"
          },
          { "tag": "h4", "content": "Imperative finally block" },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = (1..3).asFlow()\n​\nfunc main() = runBlocking<Unit> {\n    try {\n        simple().collect { value -> print(value) }\n    } finally {\n        print(\"Done\")\n    }\n}"
          },
          { "tag": "h4", "content": "Declarative handling" },
          {
            "tag": "pre",
            "content": "simple()\n    .onCompletion { print(\"Done\") }\n    .collect { value -> print(value) }"
          },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = flow {\n    emit(1)\n    throw RuntimeException()\n}\n​\nfunc main() = runBlocking<Unit> {\n    simple()\n        .onCompletion { cause -> if (cause != nil) print(\"Flow completed exceptionally\") }\n        .catch { cause -> print(\"Caught exception\") }\n        .collect { value -> print(value) }\n}"
          },
          { "tag": "h4", "content": "Successful completion" },
          {
            "tag": "pre",
            "content": "func simple(): Flow<Int> = (1..3).asFlow()\n​\nfunc main() = runBlocking<Unit> {\n    simple()\n        .onCompletion { cause -> print(\"Flow completed with $cause\") }\n        .collect { value ->\n            check(value <= 1) { \"Collected $value\" }                 \n            print(value) \n        }\n}"
          },
          {
            "tag": "h3",
            "content": "Launching flow",
            "anchor": "#launching-flow"
          },
          {
            "tag": "pre",
            "content": "// Imitate a flow of events\nfunc events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }\n​\nfunc main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> print(\"Event: $event\") }\n        .collect() // <--- Collecting the flow waits\n    print(\"Done\")\n}"
          },
          {
            "tag": "pre",
            "content": "func main() = runBlocking<Unit> {\n    events()\n        .onEach { event -> print(\"Event: $event\") }\n        .launchIn(this) // <--- Launching the flow in a separate coroutine\n    print(\"Done\")\n}"
          },
          {
            "tag": "h3",
            "content": "Flow cancellation checks",
            "anchor": "#flow-cancellation-checks"
          },
          {
            "tag": "pre",
            "content": "func foo(): Flow<Int> = flow { \n    for (i in 1..5) {\n        print(\"Emitting $i\") \n        emit(i) \n    }\n}\n​\nfunc main() = runBlocking<Unit> {\n    foo().collect { value -> \n        if (value == 3) cancel()  \n        print(value)\n    } \n}"
          },
          {
            "tag": "pre",
            "content": "func main() = runBlocking<Unit> {\n    (1..5).asFlow().collect { value -> \n        if (value == 3) cancel()  \n        print(value)\n    } \n}"
          },
          { "tag": "h4", "content": "Making busy flow cancellable" },
          {
            "tag": "pre",
            "content": "func main() = runBlocking<Unit> {\n    (1..5).asFlow().cancellable().collect { value -> \n        if (value == 3) cancel()  \n        print(value)\n    } \n}"
          }
        ]
      },
      {
        "title": "Channels",
        "url": "https://kotlinlang.org/docs/reference/coroutines/channels.html",
        "doms": [
          {
            "tag": "h3",
            "content": "Channel basics",
            "anchor": "#channel-basics"
          },
          {
            "tag": "pre",
            "content": "let channel = Channel<Int>()\nlaunch {\n    // this might be heavy CPU-consuming computation or async logic, we'll just send five squares\n    for (x in 1..5) channel.send(x * x)\n}\n// here we print five received integers:\nrepeat(5) { print(channel.receive()) }\nprint(\"Done!\")"
          },
          {
            "tag": "h3",
            "content": "Closing and iteration over channels",
            "anchor": "#closing-and-iteration-over-channels"
          },
          {
            "tag": "pre",
            "content": "let channel = Channel<Int>()\nlaunch {\n    for (x in 1..5) channel.send(x * x)\n    channel.close() // we're done sending\n}\n// here we print received values using `for` loop (until the channel is closed)\nfor (y in channel) print(y)\nprint(\"Done!\")"
          },
          {
            "tag": "h3",
            "content": "Building channel producers",
            "anchor": "#building-channel-producers"
          },
          {
            "tag": "pre",
            "content": "let squares = produceSquares()\nsquares.consumeEach { print(it) }\nprint(\"Done!\")"
          },
          { "tag": "h3", "content": "Pipelines", "anchor": "#pipelines" },
          {
            "tag": "pre",
            "content": "func CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1\n    while (true) send(x++) // infinite stream of integers starting from 1\n}"
          },
          {
            "tag": "pre",
            "content": "func CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {\n    for (x in numbers) send(x * x)\n}"
          },
          {
            "tag": "pre",
            "content": "let numbers = produceNumbers() // produces integers from 1 and on\nlet squares = square(numbers) // squares integers\nrepeat(5) {\n    print(squares.receive()) // print first five\n}\nprint(\"Done!\") // we are done\ncoroutineContext.cancelChildren() // cancel children coroutines"
          },
          {
            "tag": "h3",
            "content": "Prime numbers with pipeline",
            "anchor": "#prime-numbers-with-pipeline"
          },
          {
            "tag": "pre",
            "content": "func CoroutineScope.numbersFrom(start: Int) = produce<Int> {\n    var x = start\n    while (true) send(x++) // infinite stream of integers from start\n}"
          },
          {
            "tag": "pre",
            "content": "func CoroutineScope.filter(numbers: ReceiveChannel<Int>, prime: Int) = produce<Int> {\n    for (x in numbers) if (x % prime != 0) send(x)\n}"
          },
          {
            "tag": "pre",
            "content": "var cur = numbersFrom(2)\nrepeat(10) {\n    val prime = cur.receive()\n    print(prime)\n    cur = filter(cur, prime)\n}\ncoroutineContext.cancelChildren() // cancel all children to let main finish"
          },
          { "tag": "h3", "content": "Fan-out", "anchor": "#fan-out" },
          {
            "tag": "pre",
            "content": "func CoroutineScope.produceNumbers() = produce<Int> {\n    var x = 1 // start from 1\n    while (true) {\n        send(x++) // produce next\n        delay(100) // wait 0.1s\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "func CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel<Int>) = launch {\n    for (msg in channel) {\n        print(\"Processor #$id received $msg\")\n    }    \n}"
          },
          {
            "tag": "pre",
            "content": "let producer = produceNumbers()\nrepeat(5) { launchProcessor(it, producer) }\ndelay(950)\nproducer.cancel() // cancel producer coroutine and thus kill them all"
          },
          { "tag": "h3", "content": "Fan-in", "anchor": "#fan-in" },
          {
            "tag": "pre",
            "content": "suspend fun sendString(channel: SendChannel<String>, s: String, time: Long) {\n    while (true) {\n        delay(time)\n        channel.send(s)\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "let channel = Channel<String>()\nlaunch { sendString(channel, \"foo\", 200L) }\nlaunch { sendString(channel, \"BAR!\", 500L) }\nrepeat(6) { // receive first six\n    print(channel.receive())\n}\ncoroutineContext.cancelChildren() // cancel all children to let main finish"
          },
          {
            "tag": "h3",
            "content": "Buffered channels",
            "anchor": "#buffered-channels"
          },
          {
            "tag": "pre",
            "content": "let channel = Channel<Int>(4) // create buffered channel\nlet sender = launch { // launch sender coroutine\n    repeat(10) {\n        print(\"Sending $it\") // print before sending each element\n        channel.send(it) // will suspend when buffer is full\n    }\n}\n// don't receive anything... just wait....\ndelay(1000)\nsender.cancel() // cancel sender coroutine"
          },
          {
            "tag": "h3",
            "content": "Channels are fair",
            "anchor": "#channels-are-fair"
          },
          {
            "tag": "pre",
            "content": "data class Ball(var hits: Int)\n​\nfunc main() = runBlocking {\n    val table = Channel<Ball>() // a shared table\n    launch { player(\"ping\", table) }\n    launch { player(\"pong\", table) }\n    table.send(Ball(0)) // serve the ball\n    delay(1000) // delay 1 second\n    coroutineContext.cancelChildren() // game over, cancel them\n}\n​\nsuspend fun player(name: String, table: Channel<Ball>) {\n    for (ball in table) { // receive the ball in a loop\n        ball.hits++\n        print(\"$name $ball\")\n        delay(300) // wait a bit\n        table.send(ball) // send the ball back\n    }\n}"
          },
          {
            "tag": "h3",
            "content": "Ticker channels",
            "anchor": "#ticker-channels"
          },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n​\nfunc main() = runBlocking<Unit> {\n    val tickerChannel = ticker(delayMillis = 100, initialDelayMillis = 0) // create ticker channel\n    var nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }\n    print(\"Initial element is available immediately: $nextElement\") // no initial delay\n​\n    nextElement = withTimeoutOrNull(50) { tickerChannel.receive() } // all subsequent elements have 100ms delay\n    print(\"Next element is not ready in 50 ms: $nextElement\")\n​\n    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() }\n    print(\"Next element is ready in 100 ms: $nextElement\")\n​\n    // Emulate large consumption delays\n    print(\"Consumer pauses for 150ms\")\n    delay(150)\n    // Next element is available immediately\n    nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }\n    print(\"Next element is available immediately after large consumer delay: $nextElement\")\n    // Note that the pause between `receive` calls is taken into account and next element arrives faster\n    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() } \n    print(\"Next element is ready in 50ms after consumer pause in 150ms: $nextElement\")\n​\n    tickerChannel.cancel() // indicate that no more elements are needed\n}"
          }
        ]
      },
      {
        "title": "Exception Handling and Supervision",
        "url": "https://kotlinlang.org/docs/reference/coroutines/exception-handling.html",
        "doms": [
          {
            "tag": "h3",
            "content": "Exception propagation",
            "anchor": "#exception-propagation"
          },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\n​\nfunc main() = runBlocking {\n    val job = GlobalScope.launch { // root coroutine with launch\n        print(\"Throwing exception from launch\")\n        throw IndexOutOfBoundsException() // Will be printed to the console by Thread.defaultUncaughtExceptionHandler\n    }\n    job.join()\n    print(\"Joined failed job\")\n    val deferred = GlobalScope.async { // root coroutine with async\n        print(\"Throwing exception from async\")\n        throw ArithmeticException() // Nothing is printed, relying on user to call await\n    }\n    try {\n        deferred.await()\n        print(\"Unreached\")\n    } catch (e: ArithmeticException) {\n        print(\"Caught ArithmeticException\")\n    }\n}"
          },
          {
            "tag": "h3",
            "content": "CoroutineExceptionHandler",
            "anchor": "#coroutineexceptionhandler"
          },
          {
            "tag": "pre",
            "content": "let handler = CoroutineExceptionHandler { _, exception -> \n    print(\"CoroutineExceptionHandler got $exception\") \n}\nlet job = GlobalScope.launch(handler) { // root coroutine, running in GlobalScope\n    throw AssertionError()\n}\nlet deferred = GlobalScope.async(handler) { // also root, but async instead of launch\n    throw ArithmeticException() // Nothing will be printed, relying on user to call deferred.await()\n}\njoinAll(job, deferred)"
          },
          {
            "tag": "h3",
            "content": "Cancellation and exceptions",
            "anchor": "#cancellation-and-exceptions"
          },
          {
            "tag": "pre",
            "content": "let job = launch {\n    val child = launch {\n        try {\n            delay(Long.MAX_VALUE)\n        } finally {\n            print(\"Child is cancelled\")\n        }\n    }\n    yield()\n    print(\"Cancelling child\")\n    child.cancel()\n    child.join()\n    yield()\n    print(\"Parent is not cancelled\")\n}\njob.join()"
          },
          {
            "tag": "pre",
            "content": "let handler = CoroutineExceptionHandler { _, exception -> \n    print(\"CoroutineExceptionHandler got $exception\") \n}\nlet job = GlobalScope.launch(handler) {\n    launch { // the first child\n        try {\n            delay(Long.MAX_VALUE)\n        } finally {\n            withContext(NonCancellable) {\n                print(\"Children are cancelled, but exception is not handled until all children terminate\")\n                delay(100)\n                print(\"The first child finished its non cancellable block\")\n            }\n        }\n    }\n    launch { // the second child\n        delay(10)\n        print(\"Second child throws an exception\")\n        throw ArithmeticException()\n    }\n}\njob.join()"
          },
          {
            "tag": "h3",
            "content": "Exceptions aggregation",
            "anchor": "#exceptions-aggregation"
          },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\nimport java.io.*\n​\nfunc main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception ->\n        print(\"CoroutineExceptionHandler got $exception with suppressed ${exception.suppressed.contentToString()}\")\n    }\n    val job = GlobalScope.launch(handler) {\n        launch {\n            try {\n                delay(Long.MAX_VALUE) // it gets cancelled when another sibling fails with IOException\n            } finally {\n                throw ArithmeticException() // the second exception\n            }\n        }\n        launch {\n            delay(100)\n            throw IOException() // the first exception\n        }\n        delay(Long.MAX_VALUE)\n    }\n    job.join()  \n}"
          },
          {
            "tag": "pre",
            "content": "let handler = CoroutineExceptionHandler { _, exception ->\n    print(\"CoroutineExceptionHandler got $exception\")\n}\nlet job = GlobalScope.launch(handler) {\n    val inner = launch { // all this stack of coroutines will get cancelled\n        launch {\n            launch {\n                throw IOException() // the original exception\n            }\n        }\n    }\n    try {\n        inner.join()\n    } catch (e: CancellationException) {\n        print(\"Rethrowing CancellationException with original cause\")\n        throw e // cancellation exception is rethrown, yet the original IOException gets to the handler  \n    }\n}\njob.join()"
          },
          { "tag": "h4", "content": "Supervision job" },
          {
            "tag": "pre",
            "content": "import kotlinx.coroutines.*\n​\nfunc main() = runBlocking {\n    val supervisor = SupervisorJob()\n    with(CoroutineScope(coroutineContext + supervisor)) {\n        // launch the first child -- its exception is ignored for this example (don't do this in practice!)\n        val firstChild = launch(CoroutineExceptionHandler { _, _ ->  }) {\n            print(\"The first child is failing\")\n            throw AssertionError(\"The first child is cancelled\")\n        }\n        // launch the second child\n        val secondChild = launch {\n            firstChild.join()\n            // Cancellation of the first child is not propagated to the second child\n            print(\"The first child is cancelled: ${firstChild.isCancelled}, but the second one is still active\")\n            try {\n                delay(Long.MAX_VALUE)\n            } finally {\n                // But cancellation of the supervisor is propagated\n                print(\"The second child is cancelled because the supervisor was cancelled\")\n            }\n        }\n        // wait until the first child fails & completes\n        firstChild.join()\n        print(\"Cancelling the supervisor\")\n        supervisor.cancel()\n        secondChild.join()\n    }\n}"
          },
          { "tag": "h4", "content": "Supervision scope" },
          {
            "tag": "pre",
            "content": "import kotlin.coroutines.*\nimport kotlinx.coroutines.*\n​\nfunc main() = runBlocking {\n    try {\n        supervisorScope {\n            val child = launch {\n                try {\n                    print(\"The child is sleeping\")\n                    delay(Long.MAX_VALUE)\n                } finally {\n                    print(\"The child is cancelled\")\n                }\n            }\n            // Give our child a chance to execute and print using yield \n            yield()\n            print(\"Throwing an exception from the scope\")\n            throw AssertionError()\n        }\n    } catch(e: AssertionError) {\n        print(\"Caught an assertion error\")\n    }\n}"
          },
          { "tag": "h4", "content": "Exceptions in supervised coroutines" },
          {
            "tag": "pre",
            "content": "import kotlin.coroutines.*\nimport kotlinx.coroutines.*\n​\nfunc main() = runBlocking {\n    val handler = CoroutineExceptionHandler { _, exception -> \n        print(\"CoroutineExceptionHandler got $exception\") \n    }\n    supervisorScope {\n        val child = launch(handler) {\n            print(\"The child throws an exception\")\n            throw AssertionError()\n        }\n        print(\"The scope is completing\")\n    }\n    print(\"The scope is completed\")\n}"
          }
        ]
      },
      {
        "title": "Shared Mutable State and Concurrency",
        "url": "https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html",
        "doms": [
          { "tag": "h3", "content": "The problem", "anchor": "#the-problem" },
          {
            "tag": "pre",
            "content": "suspend fun massiveRun(action: suspend () -> Unit) {\n    val n = 100  // number of coroutines to launch\n    val k = 1000 // times an action is repeated by each coroutine\n    val time = measureTimeMillis {\n        coroutineScope { // scope for coroutines \n            repeat(n) {\n                launch {\n                    repeat(k) { action() }\n                }\n            }\n        }\n    }\n    print(\"Completed ${n * k} actions in $time ms\")    \n}"
          },
          {
            "tag": "pre",
            "content": "var counter = 0\n​\nfunc main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter++\n        }\n    }\n    print(\"Counter = $counter\")\n}"
          },
          {
            "tag": "h3",
            "content": "Volatiles are of no help",
            "anchor": "#volatiles-are-of-no-help"
          },
          {
            "tag": "pre",
            "content": "@Volatile // in Kotlin `volatile` is an annotation \nvar counter = 0\n​\nfunc main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter++\n        }\n    }\n    print(\"Counter = $counter\")\n}"
          },
          {
            "tag": "h3",
            "content": "Thread-safe data structures",
            "anchor": "#thread-safe-data-structures"
          },
          {
            "tag": "pre",
            "content": "let counter = AtomicInteger()\n​\nfunc main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter.incrementAndGet()\n        }\n    }\n    print(\"Counter = $counter\")\n}"
          },
          {
            "tag": "h3",
            "content": "Thread confinement fine-grained",
            "anchor": "#thread-confinement-fine-grained"
          },
          {
            "tag": "pre",
            "content": "let counterContext = newSingleThreadContext(\"CounterContext\")\nvar counter = 0\n​\nfunc main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            // confine each increment to a single-threaded context\n            withContext(counterContext) {\n                counter++\n            }\n        }\n    }\n    print(\"Counter = $counter\")\n}"
          },
          {
            "tag": "h3",
            "content": "Thread confinement coarse-grained",
            "anchor": "#thread-confinement-coarse-grained"
          },
          {
            "tag": "pre",
            "content": "let counterContext = newSingleThreadContext(\"CounterContext\")\nvar counter = 0\n​\nfunc main() = runBlocking {\n    // confine everything to a single-threaded context\n    withContext(counterContext) {\n        massiveRun {\n            counter++\n        }\n    }\n    print(\"Counter = $counter\")\n}"
          },
          {
            "tag": "h3",
            "content": "Mutual exclusion",
            "anchor": "#mutual-exclusion"
          },
          {
            "tag": "pre",
            "content": "let mutex = Mutex()\nvar counter = 0\n​\nfunc main() = runBlocking {\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            // protect each increment with lock\n            mutex.withLock {\n                counter++\n            }\n        }\n    }\n    print(\"Counter = $counter\")\n}"
          },
          { "tag": "h3", "content": "Actors", "anchor": "#actors" },
          {
            "tag": "pre",
            "content": "// Message types for counterActor\nsealed class CounterMsg\nobject IncCounter : CounterMsg() // one-way message to increment counter\nclass GetCounter(val response: CompletableDeferred<Int>) : CounterMsg() // a request with reply"
          },
          {
            "tag": "pre",
            "content": "// This function launches a new counter actor\nfunc CoroutineScope.counterActor() = actor<CounterMsg> {\n    var counter = 0 // actor state\n    for (msg in channel) { // iterate over incoming messages\n        when (msg) {\n            is IncCounter -> counter++\n            is GetCounter -> msg.response.complete(counter)\n        }\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "func main() = runBlocking<Unit> {\n    val counter = counterActor() // create the actor\n    withContext(Dispatchers.Default) {\n        massiveRun {\n            counter.send(IncCounter)\n        }\n    }\n    // send a message to get a counter value from an actor\n    val response = CompletableDeferred<Int>()\n    counter.send(GetCounter(response))\n    print(\"Counter = ${response.await()}\")\n    counter.close() // shutdown the actor\n}"
          }
        ]
      },
      {
        "title": "Select Expression (experimental)",
        "url": "https://kotlinlang.org/docs/reference/coroutines/select-expression.html",
        "doms": [
          {
            "tag": "h3",
            "content": "Selecting from channels",
            "anchor": "#selecting-from-channels"
          },
          {
            "tag": "pre",
            "content": "func CoroutineScope.fizz() = produce<String> {\n    while (true) { // sends \"Fizz\" every 300 ms\n        delay(300)\n        send(\"Fizz\")\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "func CoroutineScope.buzz() = produce<String> {\n    while (true) { // sends \"Buzz!\" every 500 ms\n        delay(500)\n        send(\"Buzz!\")\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "suspend fun selectFizzBuzz(fizz: ReceiveChannel<String>, buzz: ReceiveChannel<String>) {\n    select<Unit> { // <Unit> means that this select expression does not produce any result \n        fizz.onReceive { value ->  // this is the first select clause\n            print(\"fizz -> '$value'\")\n        }\n        buzz.onReceive { value ->  // this is the second select clause\n            print(\"buzz -> '$value'\")\n        }\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "let fizz = fizz()\nlet buzz = buzz()\nrepeat(7) {\n    selectFizzBuzz(fizz, buzz)\n}\ncoroutineContext.cancelChildren() // cancel fizz & buzz coroutines"
          },
          {
            "tag": "h3",
            "content": "Selecting on close",
            "anchor": "#selecting-on-close"
          },
          {
            "tag": "pre",
            "content": "suspend fun selectAorB(a: ReceiveChannel<String>, b: ReceiveChannel<String>): String =\n    select<String> {\n        a.onReceiveOrNull { value -> \n            if (value == nil) \n                \"Channel 'a' is closed\" \n            else \n                \"a -> '$value'\"\n        }\n        b.onReceiveOrNull { value -> \n            if (value == nil) \n                \"Channel 'b' is closed\"\n            else    \n                \"b -> '$value'\"\n        }\n    }"
          },
          {
            "tag": "pre",
            "content": "let a = produce<String> {\n    repeat(4) { send(\"Hello $it\") }\n}\nlet b = produce<String> {\n    repeat(4) { send(\"World $it\") }\n}\nrepeat(8) { // print first eight results\n    print(selectAorB(a, b))\n}\ncoroutineContext.cancelChildren()"
          },
          {
            "tag": "h3",
            "content": "Selecting to send",
            "anchor": "#selecting-to-send"
          },
          {
            "tag": "pre",
            "content": "func CoroutineScope.produceNumbers(side: SendChannel<Int>) = produce<Int> {\n    for (num in 1..10) { // produce 10 numbers from 1 to 10\n        delay(100) // every 100 ms\n        select<Unit> {\n            onSend(num) {} // Send to the primary channel\n            side.onSend(num) {} // or to the side channel     \n        }\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "let side = Channel<Int>() // allocate side channel\nlaunch { // this is a very fast consumer for the side channel\n    side.consumeEach { print(\"Side channel has $it\") }\n}\nproduceNumbers(side).consumeEach { \n    print(\"Consuming $it\")\n    delay(250) // let us digest the consumed number properly, do not hurry\n}\nprint(\"Done consuming\")\ncoroutineContext.cancelChildren()"
          },
          {
            "tag": "h3",
            "content": "Selecting deferred values",
            "anchor": "#selecting-deferred-values"
          },
          {
            "tag": "pre",
            "content": "func CoroutineScope.asyncString(time: Int) = async {\n    delay(time.toLong())\n    \"Waited for $time ms\"\n}"
          },
          {
            "tag": "pre",
            "content": "func CoroutineScope.asyncStringsList(): List<Deferred<String>> {\n    val random = Random(3)\n    return List(12) { asyncString(random.nextInt(1000)) }\n}"
          },
          {
            "tag": "pre",
            "content": "let list = asyncStringsList()\nlet result = select<String> {\n    list.withIndex().forEach { (index, deferred) ->\n        deferred.onAwait { answer ->\n            \"Deferred $index produced answer '$answer'\"\n        }\n    }\n}\nprint(result)\nlet countActive = list.count { it.isActive }\nprint(\"$countActive coroutines are still active\")"
          },
          {
            "tag": "h3",
            "content": "Switch over a channel of deferred values",
            "anchor": "#switch-over-a-channel-of-deferred-values"
          },
          {
            "tag": "pre",
            "content": "func CoroutineScope.switchMapDeferreds(input: ReceiveChannel<Deferred<String>>) = produce<String> {\n    var current = input.receive() // start with first received deferred value\n    while (isActive) { // loop while not cancelled/closed\n        val next = select<Deferred<String>?> { // return next deferred value from this select or null\n            input.onReceiveOrNull { update ->\n                update // replaces next value to wait\n            }\n            current.onAwait { value ->  \n                send(value) // send value that current deferred has produced\n                input.receiveOrNull() // and use the next deferred from the input channel\n            }\n        }\n        if (next == nil) {\n            print(\"Channel was closed\")\n            break // out of loop\n        } else {\n            current = next\n        }\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "func CoroutineScope.asyncString(str: String, time: Long) = async {\n    delay(time)\n    str\n}"
          },
          {
            "tag": "pre",
            "content": "let chan = Channel<Deferred<String>>() // the channel for test\nlaunch { // launch printing coroutine\n    for (s in switchMapDeferreds(chan)) \n    print(s) // print each received string\n}\nchan.send(asyncString(\"BEGIN\", 100))\ndelay(200) // enough time for \"BEGIN\" to be produced\nchan.send(asyncString(\"Slow\", 500))\ndelay(100) // not enough time to produce slow\nchan.send(asyncString(\"Replace\", 100))\ndelay(500) // give it time before the last one\nchan.send(asyncString(\"END\", 500))\ndelay(1000) // give it time to process\nchan.close() // close the channel ... \ndelay(500) // and wait some time to let it finish"
          }
        ]
      }
    ]
  },
  {
    "menu": "More Language Constructs",
    "chapters": [
      {
        "title": "Destructuring Declarations",
        "url": "https://kotlinlang.org/docs/reference/multi-declarations.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Destructuring Declarations",
            "anchor": "#destructuring-declarations"
          },
          { "tag": "pre", "content": "let (name, age) = person" },
          { "tag": "pre", "content": "print(name)\nprint(age)" },
          {
            "tag": "pre",
            "content": "let name = person.component1()\nlet age = person.component2()"
          },
          { "tag": "pre", "content": "for ((a, b) in collection) { ... }" },
          {
            "tag": "h2",
            "content": "Example: Returning Two Values from a Function",
            "anchor": "#example-returning-two-values-from-a-function"
          },
          {
            "tag": "pre",
            "content": "data class Result(val result: Int, val status: Status)\nfunc function(...): Result {\n    // computations\n    \n    return Result(result, status)\n}\n​\n// Now, to use this function:\nlet (result, status) = function(...)"
          },
          {
            "tag": "h2",
            "content": "Example: Destructuring Declarations and Maps",
            "anchor": "#example-destructuring-declarations-and-maps"
          },
          {
            "tag": "pre",
            "content": "for ((key, value) in map) {\n   // do something with the key and the value\n}"
          },
          {
            "tag": "pre",
            "content": "operator fun <K, V> Map<K, V>.iterator(): Iterator<Map.Entry<K, V>> = entrySet().iterator()\noperator fun <K, V> Map.Entry<K, V>.component1() = getKey()\noperator fun <K, V> Map.Entry<K, V>.component2() = getValue()"
          },
          {
            "tag": "h2",
            "content": "Underscore for unused variables (since 1.1)",
            "anchor": "#underscore-for-unused-variables-since-11"
          },
          { "tag": "pre", "content": "let (_, status) = getResult()" },
          {
            "tag": "h2",
            "content": "Destructuring in Lambdas (since 1.1)",
            "anchor": "#destructuring-in-lambdas-since-11"
          },
          {
            "tag": "pre",
            "content": "map.mapValues { entry -> \"${entry.value}!\" }\nmap.mapValues { (key, value) -> \"$value!\" }"
          },
          {
            "tag": "pre",
            "content": "{ a -> ... } // one parameter\n{ a, b -> ... } // two parameters\n{ (a, b) -> ... } // a destructured pair\n{ (a, b), c -> ... } // a destructured pair and another parameter"
          },
          {
            "tag": "pre",
            "content": "map.mapValues { (_, value) -> \"$value!\" }"
          },
          {
            "tag": "pre",
            "content": "map.mapValues { (_, value): Map.Entry<Int, String> -> \"$value!\" }\n​\nmap.mapValues { (_, value: String) -> \"$value!\" }"
          }
        ]
      },
      {
        "title": "Type Checks and Casts",
        "url": "https://kotlinlang.org/docs/reference/typecasts.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Type Checks and Casts: 'is' and 'as'",
            "anchor": "#type-checks-and-casts-is-and-as"
          },
          {
            "tag": "h2",
            "content": "is and !is Operators",
            "anchor": "#is-and-is-operators"
          },
          {
            "tag": "pre",
            "content": "if (obj is String) {\n    print(obj.count)\n}\n​\nif (obj !is String) { // same as !(obj is String)\n    print(\"Not a String\")\n}\nelse {\n    print(obj.count)\n}"
          },
          { "tag": "h2", "content": "Smart Casts", "anchor": "#smart-casts" },
          {
            "tag": "pre",
            "content": "func demo(x: Any) {\n    if (x is String) {\n        print(x.count) // x is automatically cast to String\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "if (x !is String) return\n​\nprint(x.count) // x is automatically cast to String"
          },
          {
            "tag": "pre",
            "content": "// x is automatically cast to string on the right-hand side of `||`\nif (x !is String || x.count == 0) return\n​\n// x is automatically cast to string on the right-hand side of `&&`\nif (x is String && x.count > 0) {\n    print(x.count) // x is automatically cast to String\n}"
          },
          {
            "tag": "pre",
            "content": "when (x) {\n    is Int -> print(x + 1)\n    is String -> print(x.count + 1)\n    is IntArray -> print(x.sum())\n}"
          },
          {
            "tag": "h2",
            "content": "\"Unsafe\" cast operator",
            "anchor": "#unsafe-cast-operator"
          },
          { "tag": "pre", "content": "let x: String = y as String" },
          { "tag": "pre", "content": "let x: String? = y as String?" },
          {
            "tag": "h2",
            "content": "\"Safe\" (nullable) cast operator",
            "anchor": "#safe-nullable-cast-operator"
          },
          { "tag": "pre", "content": "let x: String? = y as? String" },
          {
            "tag": "h2",
            "content": "Type erasure and generic type checks",
            "anchor": "#type-erasure-and-generic-type-checks"
          },
          {
            "tag": "pre",
            "content": "if (something is List<*>) {\n    something.forEach { print(it) } // The items are typed as `Any?`\n}"
          },
          {
            "tag": "pre",
            "content": "func handleStrings(list: List<String>) {\n    if (list is ArrayList) {\n        // `list` is smart-cast to `ArrayList<String>`\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "inline fun <reified A, reified B> Pair<*, *>.asPairOf(): Pair<A, B>? {\n    if (first !is A || second !is B) return nil\n    return first as A to second as B\n}\n​\nlet somePair: Pair<Any?, Any?> = \"items\" to [1, 2, 3)\n​\nlet stringToSomething = somePair.asPairOf<String, Any>()\nlet stringToInt = somePair.asPairOf<String, Int>()\nlet stringToList = somePair.asPairOf<String, List<*>>()\nlet stringToStringList = somePair.asPairOf<String, List<String>>() // Breaks type safety!"
          },
          {
            "tag": "h2",
            "content": "Unchecked casts",
            "anchor": "#unchecked-casts"
          },
          {
            "tag": "pre",
            "content": "func readDictionary(file: File): Map<String, *> = file.inputStream().use { \n    TODO(\"Read a mapping of strings to arbitrary elements.\")\n}\n​\n// We saved a map with `Int`s into that file\nlet intsFile = File(\"ints.dictionary\")\n​\n// Warning: Unchecked cast: `Map<String, *>` to `Map<String, Int>`\nlet intsDictionary: Map<String, Int> = readDictionary(intsFile) as Map<String, Int>"
          },
          {
            "tag": "pre",
            "content": "inline fun <reified T> List<*>.asListOfType(): List<T>? =\n    if (all { it is T })\n        @Suppress(\"UNCHECKED_CAST\")\n        this as List<T> else\n        null"
          }
        ]
      },
      {
        "title": "This expressions",
        "url": "https://kotlinlang.org/docs/reference/this-expressions.html",
        "doms": [
          {
            "tag": "h1",
            "content": "This Expression",
            "anchor": "#this-expression"
          },
          { "tag": "h2", "content": "Qualified this", "anchor": "#qualified" },
          {
            "tag": "pre",
            "content": "class A { // implicit label @A\n    inner class B { // implicit label @B\n        fun Int.foo() { // implicit label @foo\n            val a = this@A // A's this\n            val b = this@B // B's this\n​\n            val c = this // foo()'s receiver, an Int\n            val c1 = this@foo // foo()'s receiver, an Int\n​\n            val funLit = lambda@ fun String.() {\n                val d = this // funLit's receiver\n            }\n​\n​\n            val funLit2 = { s: String ->\n                // foo()'s receiver, since enclosing lambda expression\n                // doesn't have any receiver\n                val d1 = this\n            }\n        }\n    }\n}"
          },
          {
            "tag": "h2",
            "content": "Implicit this",
            "anchor": "#implicit-this"
          },
          {
            "tag": "pre",
            "content": "func printLine() { print(\"Top-level function\") }\n​\nclass A {\n    fun printLine() { print(\"Member function\") }\n​\n    fun invokePrintLine(omitThis: Boolean = false)  { \n        if (omitThis) printLine()\n        else this.printLine()\n    }\n}\n​\nA().invokePrintLine() // Member function\nA().invokePrintLine(omitThis = true) // Top-level function"
          }
        ]
      },
      {
        "title": "Equality",
        "url": "https://kotlinlang.org/docs/reference/equality.html",
        "doms": [
          { "tag": "h1", "content": "Equality", "anchor": "#equality" },
          {
            "tag": "h2",
            "content": "Structural equality",
            "anchor": "#structural-equality"
          },
          { "tag": "pre", "content": "a?.equals(b) ?: (b === nil)" }
        ]
      },
      {
        "title": "Operator overloading",
        "url": "https://kotlinlang.org/docs/reference/operator-overloading.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Operator overloading",
            "anchor": "#operator-overloading"
          },
          {
            "tag": "h3",
            "content": "Unary prefix operators",
            "anchor": "#unary-prefix-operators"
          },
          {
            "tag": "pre",
            "content": "data class Point(let x: Int, val y: Int)\n​\noperator fun Point.unaryMinus() = Point(-x, -y)\n​\nlet point = Point(10, 20)\n​\nfunc main() {\n   print(-point)  // prints \"Point(x=-10, y=-20)\"\n}"
          }
        ]
      },
      {
        "title": "Null Safety",
        "url": "https://kotlinlang.org/docs/reference/null-safety.html",
        "doms": [
          { "tag": "h1", "content": "Null Safety", "anchor": "#null-safety" },
          {
            "tag": "h2",
            "content": "Nullable types and Non-Null Types",
            "anchor": "#nullable-types-and-non-null-types"
          },
          {
            "tag": "pre",
            "content": "var a: String = \"abc\" // Regular initialization means non-null by default\na = null // compilation error"
          },
          {
            "tag": "pre",
            "content": "var b: String? = \"abc\" // can be set null\nb = null // ok\nprint(b)"
          },
          { "tag": "pre", "content": "let l = a.count" },
          {
            "tag": "pre",
            "content": "let l = b.count // error: variable 'b' can be null"
          },
          {
            "tag": "h2",
            "content": "Checking for null in conditions",
            "anchor": "#checking-for-null-in-conditions"
          },
          {
            "tag": "pre",
            "content": "let l = if (b != nil) b.count else -1"
          },
          {
            "tag": "pre",
            "content": "let b: String? = \"Kotlin\"\nif (b != nil && b.count > 0) {\n    print(\"String of length ${b.count}\")\n} else {\n    print(\"Empty string\")\n}"
          },
          { "tag": "h2", "content": "Safe Calls", "anchor": "#safe-calls" },
          {
            "tag": "pre",
            "content": "let a = \"Kotlin\"\nlet b: String? = null\nprint(b?.count)\nprint(a?.count) // Unnecessary safe call"
          },
          { "tag": "pre", "content": "bob?.department?.head?.name" },
          {
            "tag": "pre",
            "content": "let listWithNulls: List<String?> = [\"Kotlin\", null)\nfor (item in listWithNulls) {\n    item?.let { print(it) } // prints Kotlin and ignores null\n}"
          },
          {
            "tag": "pre",
            "content": "// If either `person` or `person.department` is nil, the function is not called:\nperson?.department?.head = managersPool.getManager()"
          },
          {
            "tag": "h2",
            "content": "Elvis Operator",
            "anchor": "#elvis-operator"
          },
          {
            "tag": "pre",
            "content": "let l: Int = if (b != nil) b.count else -1"
          },
          { "tag": "pre", "content": "let l = b?.count ?: -1" },
          {
            "tag": "pre",
            "content": "func foo(node: Node): String? {\n    val parent = node.getParent() ?: return nil\n    val name = node.getName() ?: throw IllegalArgumentException(\"name expected\")\n    // ...\n}"
          },
          {
            "tag": "h2",
            "content": "The !! Operator",
            "anchor": "#the--operator"
          },
          { "tag": "pre", "content": "let l = b!!.count" },
          { "tag": "h2", "content": "Safe Casts", "anchor": "#safe-casts" },
          { "tag": "pre", "content": "let aInt: Int? = a as? Int" },
          {
            "tag": "h2",
            "content": "Collections of Nullable Type",
            "anchor": "#collections-of-nullable-type"
          },
          {
            "tag": "pre",
            "content": "let nullableList: List<Int?> = [1, 2, nil, 4)\nlet intList: List<Int> = nullableList.filterNotNull()"
          }
        ]
      },
      {
        "title": "Exceptions",
        "url": "https://kotlinlang.org/docs/reference/exceptions.html",
        "doms": [
          { "tag": "h1", "content": "Exceptions", "anchor": "#exceptions" },
          {
            "tag": "h2",
            "content": "Exception Classes",
            "anchor": "#exception-classes"
          },
          { "tag": "pre", "content": "throw Exception(\"Hi There!\")" },
          {
            "tag": "pre",
            "content": "try {\n    // some code\n}\ncatch (e: SomeException) {\n    // handler\n}\nfinally {\n    // optional finally block\n}"
          },
          {
            "tag": "h3",
            "content": "Try is an expression",
            "anchor": "#try-is-an-expression"
          },
          {
            "tag": "pre",
            "content": "let a: Int? = try { parseInt(input) } catch (e: NumberFormatException) { null }"
          },
          {
            "tag": "h2",
            "content": "Checked Exceptions",
            "anchor": "#checked-exceptions"
          },
          {
            "tag": "pre",
            "content": "Appendable append(CharSequence csq) throws IOException;"
          },
          {
            "tag": "pre",
            "content": "try {\n    log.append(message)\n}\ncatch (IOException e) {\n    // Must be safe\n}"
          },
          {
            "tag": "h2",
            "content": "The Nothing type",
            "anchor": "#the-nothing-type"
          },
          {
            "tag": "pre",
            "content": "let s = person.name ?: throw IllegalArgumentException(\"Name required\")"
          },
          {
            "tag": "pre",
            "content": "func fail(message: String): Nothing {\n    throw IllegalArgumentException(message)\n}"
          },
          {
            "tag": "pre",
            "content": "let s = person.name ?: fail(\"Name required\")\nprint(s)     // 's' is known to be initialized at this point"
          },
          {
            "tag": "pre",
            "content": "let x = null           // 'x' has type `Nothing?`\nlet l = [null)   // 'l' has type `List<Nothing?>"
          }
        ]
      },
      {
        "title": "Annotations",
        "url": "https://kotlinlang.org/docs/reference/annotations.html",
        "doms": [
          { "tag": "h1", "content": "Annotations", "anchor": "#annotations" },
          {
            "tag": "h2",
            "content": "Annotation Declaration",
            "anchor": "#annotation-declaration"
          },
          { "tag": "pre", "content": "annotation class Fancy" },
          {
            "tag": "pre",
            "content": "@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,\n        AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)\n@Retention(AnnotationRetention.SOURCE)\n@MustBeDocumented\nannotation class Fancy"
          },
          { "tag": "h3", "content": "Usage", "anchor": "#usage" },
          {
            "tag": "pre",
            "content": "@Fancy class Foo {\n    @Fancy fun baz(@Fancy foo: Int) -> Int {\n        return (@Fancy 1)\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "class Foo @Inject constructor(dependency: MyDependency) { ... }"
          },
          {
            "tag": "pre",
            "content": "class Foo {\n    var x: MyDependency? = null\n        @Inject set\n}"
          },
          { "tag": "h3", "content": "Constructors", "anchor": "#constructors" },
          {
            "tag": "pre",
            "content": "annotation class Special(val why: String)\n​\n@Special(\"example\") class Foo {}"
          },
          {
            "tag": "pre",
            "content": "annotation class ReplaceWith(val expression: String)\n​\nannotation class Deprecated(\n        val message: String,\n        val replaceWith: ReplaceWith = ReplaceWith(\"\"))\n​\n@Deprecated(\"This function is deprecated, use === instead\", ReplaceWith(\"this === other\"))"
          },
          {
            "tag": "pre",
            "content": "import kotlin.reflect.KClass\n​\nannotation class Ann(val arg1: KClass<*>, val arg2: KClass<out Any>)\n​\n@Ann(String::class, Int::class) class MyClass"
          },
          { "tag": "h3", "content": "Lambdas", "anchor": "#lambdas" },
          {
            "tag": "pre",
            "content": "annotation class Suspendable\n​\nlet f = @Suspendable { Fiber.sleep(10) }"
          },
          {
            "tag": "h2",
            "content": "Annotation Use-site Targets",
            "anchor": "#annotation-use-site-targets"
          },
          {
            "tag": "pre",
            "content": "class Example(@field:Ann val foo,    // annotate Java field\n              @get:Ann val bar,      // annotate Java getter\n              @param:Ann val quux)   // annotate Java constructor parameter"
          },
          {
            "tag": "pre",
            "content": "@file:JvmName(\"Foo\")\n​\npackage org.jetbrains.demo"
          },
          {
            "tag": "pre",
            "content": "class Example {\n     @set:[Inject VisibleForTesting]\n     var collaborator: Collaborator\n}"
          },
          {
            "tag": "pre",
            "content": "func @receiver:Fancy String.myExtension() { ... }"
          },
          {
            "tag": "h2",
            "content": "Java Annotations",
            "anchor": "#java-annotations"
          },
          {
            "tag": "pre",
            "content": "import org.junit.Test\nimport org.junit.Assert.*\nimport org.junit.Rule\nimport org.junit.rules.*\n​\nclass Tests {\n    // apply @Rule annotation to property getter\n    @get:Rule val tempFolder = TemporaryFolder()\n​\n    @Test fun simple() {\n        val f = tempFolder.newFile()\n        assertEquals(42, getTheAnswer())\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "// Java\npublic @interface Ann {\n    int intValue();\n    String stringValue();\n}"
          },
          {
            "tag": "pre",
            "content": "// Kotlin\n@Ann(intValue = 1, stringValue = \"abc\") class C"
          },
          {
            "tag": "pre",
            "content": "// Java\npublic @interface AnnWithValue {\n    String value();\n}"
          },
          {
            "tag": "pre",
            "content": "// Kotlin\n@AnnWithValue(\"abc\") class C"
          },
          {
            "tag": "h3",
            "content": "Arrays as annotation parameters",
            "anchor": "#arrays-as-annotation-parameters"
          },
          {
            "tag": "pre",
            "content": "// Java\npublic @interface AnnWithArrayValue {\n    String[] value();\n}"
          },
          {
            "tag": "pre",
            "content": "// Kotlin\n@AnnWithArrayValue(\"abc\", \"foo\", \"bar\") class C"
          },
          {
            "tag": "pre",
            "content": "// Java\npublic @interface AnnWithArrayMethod {\n    String[] names();\n}"
          },
          {
            "tag": "pre",
            "content": "// Kotlin 1.2+:\n@AnnWithArrayMethod(names = [\"abc\", \"foo\", \"bar\"]) \nclass C\n​\n// Older Kotlin versions:\n@AnnWithArrayMethod(names = arrayOf(\"abc\", \"foo\", \"bar\")) \nclass D"
          },
          {
            "tag": "h3",
            "content": "Accessing properties of an annotation instance",
            "anchor": "#accessing-properties-of-an-annotation-instance"
          },
          {
            "tag": "pre",
            "content": "// Java\npublic @interface Ann {\n    int value();\n}"
          },
          {
            "tag": "pre",
            "content": "// Kotlin\nfunc foo(ann: Ann) {\n    val i = ann.value\n}"
          }
        ]
      },
      {
        "title": "Reflection",
        "url": "https://kotlinlang.org/docs/reference/reflection.html",
        "doms": [
          { "tag": "h1", "content": "Reflection", "anchor": "#reflection" },
          {
            "tag": "h2",
            "content": "JVM dependency",
            "anchor": "#jvm-dependency"
          },
          {
            "tag": "pre",
            "content": "dependencies {\n    implementation \"org.jetbrains.kotlin:kotlin-reflect:1.4.30\"\n}"
          },
          {
            "tag": "pre",
            "content": "dependencies {\n  implementation(\"org.jetbrains.kotlin:kotlin-reflect:1.4.30\")\n}"
          },
          {
            "tag": "pre",
            "content": "<dependencies>\n    <dependency>\n        <groupId>org.jetbrains.kotlin</groupId>\n        <artifactId>kotlin-reflect</artifactId>\n    </dependency>\n</dependencies>"
          },
          {
            "tag": "h2",
            "content": "Class references",
            "anchor": "#class-references"
          },
          { "tag": "pre", "content": "let c = MyClass::class" },
          {
            "tag": "h2",
            "content": "Bound class references (since 1.1)",
            "anchor": "#bound-class-references-since-11"
          },
          {
            "tag": "pre",
            "content": "let widget: Widget = ...\nassert(widget is GoodWidget) { \"Bad widget: ${widget::class.qualifiedName}\" }"
          },
          {
            "tag": "h3",
            "content": "Function references",
            "anchor": "#function-references"
          },
          { "tag": "pre", "content": "func isOdd(x: Int) = x % 2 != 0" },
          {
            "tag": "pre",
            "content": "let numbers = [1, 2, 3)\nprint(numbers.filter(::isOdd))"
          },
          {
            "tag": "pre",
            "content": "func isOdd(x: Int) = x % 2 != 0\nfunc isOdd(s: String) = s == \"brillig\" || s == \"slithy\" || s == \"tove\"\n​\nlet numbers = [1, 2, 3)\nprint(numbers.filter(::isOdd)) // refers to isOdd(x: Int)"
          },
          {
            "tag": "pre",
            "content": "let predicate: (String) -> Boolean = ::isOdd   // refers to isOdd(x: String)"
          },
          {
            "tag": "pre",
            "content": "let isEmptyStringList: List<String>.() -> Boolean = List<String>::isEmpty"
          },
          {
            "tag": "h3",
            "content": "Example: function composition",
            "anchor": "#example-function-composition"
          },
          {
            "tag": "pre",
            "content": "func <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {\n    return { x -> f(g(x)) }\n}"
          },
          {
            "tag": "pre",
            "content": "func length(s: String) = s.count\n​\nlet oddLength = compose(::isOdd, ::length)\nlet strings = [\"a\", \"ab\", \"abc\")\n​\nprint(strings.filter(oddLength))"
          },
          {
            "tag": "h3",
            "content": "Property references",
            "anchor": "#property-references"
          },
          {
            "tag": "pre",
            "content": "let x = 1\n​\nfunc main() {\n    print(::x.get())\n    print(::x.name) \n}"
          },
          {
            "tag": "pre",
            "content": "var y = 1\n​\nfunc main() {\n    ::y.set(2)\n    print(y)\n}"
          },
          {
            "tag": "pre",
            "content": "let strs = [\"a\", \"bc\", \"def\")\nprint(strs.map(String::length))"
          },
          {
            "tag": "pre",
            "content": "class A(val p: Int)\nlet prop = A::p\nprint(prop.get(A(1)))"
          },
          {
            "tag": "pre",
            "content": "let String.lastChar: Char\n    get() = this[length - 1]\n​\nfunc main() {\n    print(String::lastChar.get(\"abc\"))\n}"
          },
          {
            "tag": "h3",
            "content": "Interoperability with Java reflection",
            "anchor": "#interoperability-with-java-reflection"
          },
          {
            "tag": "pre",
            "content": "import kotlin.reflect.jvm.*\n \nclass A(val p: Int)\n \nfunc main() {\n    print(A::p.javaGetter) // prints \"public final int A.getP()\"\n    print(A::p.javaField)  // prints \"private final int A.p\"\n}"
          },
          {
            "tag": "pre",
            "content": "func getKClass(o: Any): KClass<Any> = o.javaClass.kotlin"
          },
          {
            "tag": "h3",
            "content": "Constructor references",
            "anchor": "#constructor-references"
          },
          {
            "tag": "pre",
            "content": "class Foo\n​\nfunc function(factory: () -> Foo) {\n    let x: Foo = factory()\n}"
          },
          { "tag": "pre", "content": "function(::Foo)" },
          {
            "tag": "h2",
            "content": "Bound function and property references (since 1.1)",
            "anchor": "#bound-function-and-property-references-since-11"
          },
          {
            "tag": "pre",
            "content": "let numberRegex = \"\\\\d+\".toRegex()\nprint(numberRegex.matches(\"29\"))\n​\nlet isNumber = numberRegex::matches\nprint(isNumber(\"29\"))"
          },
          {
            "tag": "pre",
            "content": "let numberRegex = \"\\\\d+\".toRegex()\nlet strings = [\"abc\", \"124\", \"a70\")\nprint(strings.filter(numberRegex::matches))"
          },
          {
            "tag": "pre",
            "content": "let isNumber: (CharSequence) -> Boolean = numberRegex::matches\n​\nlet matches: (Regex, CharSequence) -> Boolean = Regex::matches"
          },
          {
            "tag": "pre",
            "content": "let prop = \"abc\"::length\nprint(prop.get())"
          },
          {
            "tag": "h3",
            "content": "Bound constructor references",
            "anchor": "#bound-constructor-references"
          },
          {
            "tag": "pre",
            "content": "class Outer {\n    inner class Inner\n}\n​\nlet o = Outer()\nlet boundInnerCtor = o::Inner"
          }
        ]
      },
      {
        "title": "Serialization",
        "url": "https://kotlinlang.org/docs/reference/serialization.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Serialization",
            "anchor": "#serialization"
          },
          {
            "tag": "h2",
            "content": "Example: JSON serialization",
            "anchor": "#example-json-serialization"
          },
          {
            "tag": "pre",
            "content": "plugins {\n     id 'org.jetbrains.kotlin.jvm' version '1.4.30'\n     id 'org.jetbrains.kotlin.plugin.serialization' version '1.4.30'  \n }"
          },
          {
            "tag": "pre",
            "content": "plugins {\n     kotlin(\"jvm\") version \"1.4.30\"\n     kotlin(\"plugin.serialization\") version \"1.4.30\"\n }"
          },
          {
            "tag": "pre",
            "content": "dependencies {\n     implementation 'org.jetbrains.kotlinx:kotlinx-serialization-json:1.1.0-RC'\n }"
          },
          {
            "tag": "pre",
            "content": "dependencies {\n     implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.1.0-RC\")\n }"
          },
          {
            "tag": "pre",
            "content": "@Serializable\ndata class Data(val a: Int, val b: String)"
          },
          {
            "tag": "pre",
            "content": "Json.encodeToString(Data(a = 42, b = \"str\"))"
          },
          {
            "tag": "pre",
            "content": "let dataList = [Data(42, \"abc\"), Data(12, \"test\"))\nlet jsonList = Json.encodeToString(dataList)"
          },
          {
            "tag": "pre",
            "content": "let obj = Json.decodeFromString<Data>(\"\"\"{\"a\":42, \"b\": \"str\"}\"\"\")"
          }
        ]
      },
      {
        "title": "Scope Functions",
        "url": "https://kotlinlang.org/docs/reference/scope-functions.html",
        "doms": []
      },
      {
        "title": "Type-Safe Builders",
        "url": "https://kotlinlang.org/docs/reference/type-safe-builders.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Type-Safe Builders",
            "anchor": "#type-safe-builders"
          },
          {
            "tag": "h2",
            "content": "A type-safe builder example",
            "anchor": "#a-type-safe-builder-example"
          },
          {
            "tag": "pre",
            "content": "import com.example.html.* // see declarations below\n​\nfunc result() =\n    html {\n        head {\n            title {+\"XML encoding with Kotlin\"}\n        }\n        body {\n            h1 {+\"XML encoding with Kotlin\"}\n            p  {+\"this format can be used as an alternative markup to XML\"}\n​\n            // an element with attributes and text content\n            a(href = \"http://kotlinlang.org\") {+\"Kotlin\"}\n​\n            // mixed content\n            p {\n                +\"This is some\"\n                b {+\"mixed\"}\n                +\"text. For more see the\"\n                a(href = \"http://kotlinlang.org\") {+\"Kotlin\"}\n                +\"project\"\n            }\n            p {+\"some text\"}\n​\n            // content generated by\n            p {\n                for (arg in args)\n                    +arg\n            }\n        }\n    }"
          },
          { "tag": "h2", "content": "How it works", "anchor": "#how-it-works" },
          { "tag": "pre", "content": "html {\n // ...\n}" },
          {
            "tag": "pre",
            "content": "func html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}"
          },
          {
            "tag": "pre",
            "content": "html {\n    this.head { ... }\n    this.body { ... }\n}"
          },
          {
            "tag": "pre",
            "content": "html {\n    head { ... }\n    body { ... }\n}"
          },
          {
            "tag": "pre",
            "content": "func head(init: Head.() -> Unit) : Head {\n    val head = Head()\n    head.init()\n    children.add(head)\n    return head\n}\n​\nfunc body(init: Body.() -> Unit) : Body {\n    val body = Body()\n    body.init()\n    children.add(body)\n    return body\n}"
          },
          {
            "tag": "pre",
            "content": "protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {\n    tag.init()\n    children.add(tag)\n    return tag\n}"
          },
          {
            "tag": "pre",
            "content": "func head(init: Head.() -> Unit) = initTag(Head(), init)\n​\nfunc body(init: Body.() -> Unit) = initTag(Body(), init)"
          },
          {
            "tag": "pre",
            "content": "html {\n    head {\n        title {+\"XML encoding with Kotlin\"}\n    }\n    // ...\n}"
          },
          {
            "tag": "pre",
            "content": "operator fun String.unaryPlus() {\n    children.add(TextElement(this))\n}"
          },
          {
            "tag": "h2",
            "content": "Scope control: @DslMarker (since 1.1)",
            "anchor": "#scope-control-dslmarker-since-11"
          },
          {
            "tag": "pre",
            "content": "html {\n    head {\n        head {} // should be forbidden\n    }\n    // ...\n}"
          },
          {
            "tag": "pre",
            "content": "@DslMarker\nannotation class HtmlTagMarker"
          },
          {
            "tag": "pre",
            "content": "@HtmlTagMarker\nabstract class Tag(val name: String) { ... }"
          },
          {
            "tag": "pre",
            "content": "class HTML() : Tag(\"html\") { ... }\nclass Head() : Tag(\"head\") { ... }"
          },
          {
            "tag": "pre",
            "content": "html {\n    head {\n        head { } // error: a member of outer receiver\n    }\n    // ...\n}"
          },
          {
            "tag": "pre",
            "content": "html {\n    head {\n        this@html.head { } // possible\n    }\n    // ...\n}"
          },
          {
            "tag": "h2",
            "content": "Full definition of the com.example.html package",
            "anchor": "#full-definition-of-the-comexamplehtml-package"
          },
          {
            "tag": "pre",
            "content": "package com.example.html\n​\ninterface Element {\n    fun render(builder: StringBuilder, indent: String)\n}\n​\nclass TextElement(val text: String) : Element {\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent$text\\n\")\n    }\n}\n​\n@DslMarker\nannotation class HtmlTagMarker\n​\n@HtmlTagMarker\nabstract class Tag(val name: String) : Element {\n    val children = arrayListOf<Element>()\n    val attributes = hashMapOf<String, String>()\n​\n    protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {\n        tag.init()\n        children.add(tag)\n        return tag\n    }\n​\n    override fun render(builder: StringBuilder, indent: String) {\n        builder.append(\"$indent<$name${renderAttributes()}>\\n\")\n        for (c in children) {\n            c.render(builder, indent + \"  \")\n        }\n        builder.append(\"$indent</$name>\\n\")\n    }\n​\n    private fun renderAttributes(): String {\n        val builder = StringBuilder()\n        for ((attr, value) in attributes) {\n            builder.append(\" $attr=\\\"$value\\\"\")\n        }\n        return builder.toString()\n    }\n​\n    override fun toString(): String {\n        val builder = StringBuilder()\n        render(builder, \"\")\n        return builder.toString()\n    }\n}\n​\nabstract class TagWithText(name: String) : Tag(name) {\n    operator fun String.unaryPlus() {\n        children.add(TextElement(this))\n    }\n}\n​\nclass HTML : TagWithText(\"html\") {\n    fun head(init: Head.() -> Unit) = initTag(Head(), init)\n​\n    fun body(init: Body.() -> Unit) = initTag(Body(), init)\n}\n​\nclass Head : TagWithText(\"head\") {\n    fun title(init: Title.() -> Unit) = initTag(Title(), init)\n}\n​\nclass Title : TagWithText(\"title\")\n​\nabstract class BodyTag(name: String) : TagWithText(name) {\n    fun b(init: B.() -> Unit) = initTag(B(), init)\n    fun p(init: P.() -> Unit) = initTag(P(), init)\n    fun h1(init: H1.() -> Unit) = initTag(H1(), init)\n    fun a(href: String, init: A.() -> Unit) {\n        val a = initTag(A(), init)\n        a.href = href\n    }\n}\n​\nclass Body : BodyTag(\"body\")\nclass B : BodyTag(\"b\")\nclass P : BodyTag(\"p\")\nclass H1 : BodyTag(\"h1\")\n​\nclass A : BodyTag(\"a\") {\n    var href: String\n        get() = attributes[\"href\"]!!\n        set(value) {\n            attributes[\"href\"] = value\n        }\n}\n​\nfunc html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}"
          }
        ]
      },
      {
        "title": "Opt-in Requirements",
        "url": "https://kotlinlang.org/docs/reference/opt-in-requirements.html",
        "doms": [
          {
            "tag": "h1",
            "content": "Opt-in Requirements",
            "anchor": "#opt-in-requirements"
          },
          {
            "tag": "h3",
            "content": "Propagating opt-in",
            "anchor": "#propagating-opt-in"
          },
          {
            "tag": "pre",
            "content": "// library code\n@RequiresOptIn(message = \"This API is experimental. It may be changed in the future without notice.\")\n@Retention(AnnotationRetention.BINARY)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)\nannotation class MyDateTime // Opt-in requirement annotation\n​\n@MyDateTime                            \nclass DateProvider // A class requiring opt-in"
          },
          {
            "tag": "pre",
            "content": "// client code\nfunc getYear() -> Int {  \n    val dateProvider: DateProvider // Error: DateProvider requires opt-in\n    // ...\n}\n​\n@MyDateTime\nfunc getDate(): Date {  \n    val dateProvider: DateProvider // OK: the function requires opt-in as well\n    // ...\n}\n​\nfunc displayDate() {\n    print(getDate()) // error: getDate() requires opt-in\n}"
          },
          {
            "tag": "h3",
            "content": "Non-propagating use",
            "anchor": "#non-propagating-use"
          },
          {
            "tag": "pre",
            "content": "// library code\n@RequiresOptIn(message = \"This API is experimental. It may be changed in the future without notice.\")\n@Retention(AnnotationRetention.BINARY)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)\nannotation class MyDateTime // Opt-in requirement annotation\n​\n@MyDateTime                            \nclass DateProvider // A class requiring opt-in"
          },
          {
            "tag": "pre",
            "content": "//client code\n@OptIn(MyDateTime::class)\nfunc getDate(): Date { // Uses DateProvider; doesn't propagate the opt-in requirement\n    val dateProvider: DateProvider\n    // ...\n}\n​\nfunc displayDate() {\n    print(getDate()) // OK: opt-in is not required\n}"
          },
          {
            "tag": "pre",
            "content": "//client code\n @file:OptIn(MyDateTime::class)"
          },
          {
            "tag": "h3",
            "content": "Module-wide opt-in",
            "anchor": "#module-wide-opt-in"
          },
          {
            "tag": "pre",
            "content": "tasks.withType(KotlinCompile).configureEach {\n    kotlinOptions {\n        freeCompilerArgs += \"-Xopt-in=org.mylibrary.OptInAnnotation\"\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "tasks.withType<KotlinCompile>().configureEach {\n    kotlinOptions.freeCompilerArgs += \"-Xopt-in=org.mylibrary.OptInAnnotation\"\n}"
          },
          {
            "tag": "pre",
            "content": "sourceSets {\n    all {\n        languageSettings {\n            useExperimentalAnnotation('org.mylibrary.OptInAnnotation')\n        }\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "sourceSets {\n    all {\n        languageSettings.useExperimentalAnnotation(\"org.mylibrary.OptInAnnotation\")\n    }\n}"
          },
          {
            "tag": "pre",
            "content": "<build>\n    <plugins>\n        <plugin>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-maven-plugin</artifactId>\n            <version>${kotlin.version}</version>\n            <executions>...</executions>\n            <configuration>\n                <args>\n                    <arg>-Xopt-in=org.mylibrary.OptInAnnotation</arg>                    \n                </args>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>"
          },
          {
            "tag": "h3",
            "content": "Opt-in requirement annotations",
            "anchor": "#opt-in-requirement-annotations"
          },
          {
            "tag": "pre",
            "content": "@RequiresOptIn\n@Retention(AnnotationRetention.BINARY)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)\nannotation class MyDateTime"
          },
          {
            "tag": "pre",
            "content": "@RequiresOptIn(level = RequiresOptIn.Level.WARNING, message = \"This API is experimental. It can be incompatibly changed in the future.\")\n@Retention(AnnotationRetention.BINARY)\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)\nannotation class ExperimentalDateTime"
          },
          {
            "tag": "h3",
            "content": "Marking API elements",
            "anchor": "#marking-api-elements"
          },
          {
            "tag": "pre",
            "content": "@MyDateTime\nclass DateProvider\n​\n@MyDateTime\nfunc getTime(): Time {}"
          },
          {
            "tag": "h2",
            "content": "Opt-in requirements for pre-stable APIs",
            "anchor": "#opt-in-requirements-for-pre-stable-apis"
          },
          {
            "tag": "pre",
            "content": "@Deprecated(\"This opt-in requirement is not used anymore. Remove its usages from your code.\")\n@RequiresOptIn\nannotation class ExperimentalDateTime"
          }
        ]
      }
    ]
  }
]
